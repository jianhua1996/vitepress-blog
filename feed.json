{
    "version": "https://jsonfeed.org/version/1",
    "title": "Clark Cui",
    "home_page_url": "https://clark-cui.top/",
    "feed_url": "https://clark-cui.top/feed.json",
    "description": "Clark Cui' Blog",
    "icon": "https://clark-cui.top/horse.svg",
    "author": {
        "name": "Clark Cui",
        "url": "https://clark-cui.top"
    },
    "items": [
        {
            "content_html": "<h1>python 中的一些语法糖释义</h1>\n<h3>with 关键字</h3>\n<blockquote>\n<p>Python 中的  with  关键字用于异常处理，它封装了  try…except…finally  编码范式，提高了易用性，使代码更清晰可读。</p>\n</blockquote>\n<p>如果不使用不使用 with，也不使用 try…except…finally</p>\n<pre><code class=\"language-python\">file = open('./test_runoob.txt', 'w')\nfile.write('hello world !')\nfile.close()\n</code></pre>\n<p>如果使用 try…except…finally</p>\n<pre><code class=\"language-python\">file = open('./test_runoob.txt', 'w')\ntry:\n    file.write('hello world')\nfinally:\n    file.close()\n</code></pre>\n<p>使用 with 关键字</p>\n<pre><code class=\"language-python\">with open('./test_runoob.txt', 'w') as file:\n    file.write('hello world !')\n</code></pre>\n",
            "url": "https://clark-cui.top/posts/python 中的一些语法糖释义.html",
            "title": "python 中的一些语法糖释义",
            "date_modified": "2024-02-29T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>浏览器的进程模型</h2>\n<h3>进程与线程</h3>\n<p>进程是正在运行的<u>程序的实例</u>，每个进程都有自己<u>独立的</u>一块内存空间，有了进程之后，才可以运行程序的代码。一个进程至少有一个线程，叫做主线程，一个进程也可以运行多个线程，多个线程可以共享数据。</p>\n<h3>浏览器是一个多进程多线程的应用程序</h3>\n<p>浏览器是一个极其复杂的应用程序</p>\n<p>为了避免多个功能之间的相互影响，减少崩溃的几率，浏览器在启动的时候会启动多个进程。</p>\n<p><strong>其中，最主要的进程有</strong>：</p>\n<ol>\n<li>\n<p><strong>浏览器进程</strong></p>\n<p>负责界面显示、用户交互、子进程管理等。</p>\n</li>\n<li>\n<p><strong>网络进程</strong></p>\n<p>负责网络通信，各种资源的加载。</p>\n</li>\n<li>\n<p><strong>渲染进程</strong></p>\n<p>每个标签页都是一个新的渲染进程，渲染进程的主线程负责执行HTML、CSS、JS代码</p>\n</li>\n</ol>\n<h3>渲染主线程是如何工作的</h3>\n<p>渲染主线程是浏览器中最繁忙的线程，它处理的任务包括：</p>\n<ul>\n<li>\n<p>解析html</p>\n</li>\n<li>\n<p>解析css</p>\n</li>\n<li>\n<p>计算样式</p>\n</li>\n<li>\n<p>布局</p>\n</li>\n<li>\n<p>处理图层</p>\n</li>\n<li>\n<p>每秒把页面画60次</p>\n</li>\n<li>\n<p>执行全局js代码</p>\n</li>\n<li>\n<p>处理事件函数</p>\n</li>\n<li>\n<p>执行计时器的回调</p>\n</li>\n<li>\n<p>......</p>\n</li>\n</ul>\n<p>为了处理这么多任务的调度，主线程想出了一个办法：队列</p>\n<p>当渲染<u>主线程正在执行任务</u>时，由渲染主线程和浏览器<u>其他</u>线程安排的<u>任务</u>会被暂时放<u>到队列中等待执行</u>，当渲染<u>主线程中的任务执行完毕</u>，会<u>从队列中依次取出</u>排队的任务进行<u>执行</u>。</p>\n<ol>\n<li>\n<p>在最开始的时候，渲染主线程会进入一个无线循环</p>\n<pre><code class=\"language-cpp\">for(;;){\n    \n}\n</code></pre>\n</li>\n<li>\n<p>每一次循环会检查队列中是否有任务存在，如果有，就取出第一个任务进行执行，执行完后进入下一次循环；如果没有，则进入休眠状态。</p>\n</li>\n<li>\n<p>其他所有的线程（包括其他进程的线程）可以随时向队列添加任务，新添加的任务会被放到队列的末尾。添加任务时，如果主线程是休眠状态，则唤醒</p>\n</li>\n</ol>\n<h3>何为异步？</h3>\n<p>在代码执行的过程中，无法立即处理（需要等待）的任务就是异步任务，比如：</p>\n<ul>\n<li>\n<p>计时器安排的任务  <code>setTimeout</code>、<code>setInterval</code></p>\n</li>\n<li>\n<p>网络通信后执行的任务 <code>XHR</code>、<code>fetch</code></p>\n</li>\n<li>\n<p>用户操作后执行的任务 <code>addEventListner</code></p>\n</li>\n</ul>\n<p>渲染主线程不会等待以上任务的执行，而是继续执行主线程需要执行的代码。当以上任务（由浏览器的其他进程）执行完成时，会把执行后的结果放到队列中进行等待（直到主线程清空后依次从队列中取出）。</p>\n<h3>JS代码为何会阻塞渲染</h3>\n<p>因为js代码和页面渲染都会在渲染主线程中进行执行，而页面的重绘是异步的过程，需要等待主线程的js代码执行完毕。</p>\n<h3>队列中的任务有优先级吗？</h3>\n<p>队列中的任务没有优先级，都是先进先出</p>\n<p>但是<u>队列有优先级</u></p>\n<ul>\n<li>\n<p>每个任务都有一个任务类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同队列中取出任务执行</p>\n</li>\n<li>\n<p>浏览器必须准备好一个微队列，<u>微队列中的任务优先于其他所有任务执行</u>（btw:微队列，vip的v）</p>\n<p>添加任务到微队列的方式 <code>Promsie</code> 和<code>MutationObserver</code></p>\n<pre><code class=\"language-javascript\">// 立刻把一个函数放到微队列\nPromise.resolve().then(函数)\n</code></pre>\n</li>\n</ul>\n",
            "url": "https://clark-cui.top/posts/事件循环.html",
            "title": "事件循环",
            "date_modified": "2024-02-29T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>浏览器是如何渲染页面的</h2>\n<h3>什么是渲染</h3>\n<p>把html字符串转换为像素点信息的过程就可以叫做渲染</p>\n<h3>渲染的开始</h3>\n<p>当浏览器的网络线程拿到HTML文档后，会产生一个渲染任务，并将其放到队列中。</p>\n<p>在事件循环机制的作用下，渲染主线程取出队列中的渲染任务，开启渲染流程。</p>\n<h3>渲染流水线</h3>\n<ol>\n<li>\n<p>解析HTML文档</p>\n</li>\n<li>\n<p>样式计算</p>\n</li>\n<li>\n<p>布局</p>\n</li>\n<li>\n<p>分层</p>\n</li>\n<li>\n<p>绘制</p>\n</li>\n<li>\n<p>分块</p>\n</li>\n<li>\n<p>光栅化</p>\n</li>\n<li>\n<p>画</p>\n</li>\n</ol>\n<h3>1. 解析HTML - Parse HTML</h3>\n<p>最终结果是把html文档转换成<code>DOM树(文档对象模型)</code>和<code>CSSOM树(CSS 对象模型)</code></p>\n<p>渲染的第一步是解析html。</p>\n<p>解析过程中<u>遇到css解析css</u>，<u>遇到js执行js</u>。为了提高解析效率，浏览器在开始解析前，会启动一个<u>预解析的线程</u>，率先<u>下载</u>html中的<u>外部css文件</u>和<u>外部的js文件</u>。</p>\n<p>如果主线程解析到link位置，此时外部的css文件还没有下载解析好，主线程不会等待，继续后续html的解析。这就是<u>css不会阻塞html解析</u>的根本原因。</p>\n<p>如果主线程解析到script位置，会停止解析html，转而执行js代码或者等待js文件下载完毕并执行后，才继续解析html。这是因为，<u>js代码执行的过程中可能会修改当前构建好的dom</u>树，所以必须先暂停解析。<u>这就是js会阻塞html解析的根本原因</u>。</p>\n<p>第一步完成后，会得到dom树和cssom树，浏览器的默认样式会包含在cssom树中。</p>\n<h3>2. 样式计算 - Recalculate Style</h3>\n<p>主线程会遍历得到的dom树，依次为树中的每个节点计算出它最终的样式，称之为<code>Computed Style</code>。</p>\n<p>在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px</p>\n<h3>3. 布局 - Layout</h3>\n<p>主线程在进行layout计算的时候也会生成相应的layout树，需要注意的是，<u>dom树和layout树并不是一一对应的</u>。</p>\n<p>比如<code>display: none</code>的节点没有几何信息，因此不会生成到布局树；又比如一些伪元素在dom节点中不存在，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等这些都会导致dom树和布局树无法一一对应。</p>\n<h3>4. 分层 - Layer</h3>\n<p>主线程会使用一套复杂的策略对整个布局树进行分层。</p>\n<p>分层的好处是，如果一个节点经常进行变动，则只需要对该层进行后续处理，而不需要对整个树进行处理，提升了效率。</p>\n<p><u>可以通过<code>will-change</code>属性主动影响浏览器的分层结果</u>。</p>\n<h3>5. 绘制 - Paint</h3>\n<p>主线程会为每个层<u>单独生成</u>绘制指令集，用于<u>描述</u>这一层该<u>如何画出来</u>。</p>\n<h3>6. 分块 - Tiling</h3>\n<p>上一步完成后，主线程会将每个图层的绘制信息交给合成线程，剩余工作由合成线程完成。</p>\n<p>合成线程首先对每个<u>图层</u>进行<u>分块</u>，将其划分成许多的小区域。这一过程是由<u>多个线程</u>完成的。</p>\n<h3>7. 光栅化 - Raster</h3>\n<p>分块完成后，进入光栅化阶段。</p>\n<p>合成线程会将分块信息交给gpu进程，gpu会以极高的速度进行光栅化。</p>\n<p><u>光栅化的结果就是一块一块的位图</u>。</p>\n<h3>8. 画 - Draw</h3>\n<p>最后一个阶段就是画</p>\n<p>合成线程从gpu进程中拿到每个块的位图后，生成一个个<u><code>指引（quad）</code>信息</u>。</p>\n<p>指引会标识出每个位图应该画到屏幕的哪个位置，并且会考虑旋转、缩放等变形。</p>\n<p><u>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的原因</u>。</p>\n<p>合成线程会把<code>quad</code>信息交给gpu进程，由gpu进程调用gpu硬件，最终完成屏幕图像的显示。</p>\n<h3>关于reflow</h3>\n<p><u>reflow的本质就是重新计算layout树</u>。</p>\n<p>当进行了影响布局树的操作后，就需要重新计算布局树，触发layout流程。</p>\n<p>为了避免连续多次的布局树反复计算，浏览器会合并这些操作，当js代码全部完成后再进行统一的布局树计算。所以，改动属性造成的reflow是异步完成的。</p>\n<p>也正是因为如此，当我们在更改布局属性后立即获取它们的信息，就有可能造成无法获取到最新布局信息的结果。</p>\n<p>浏览器最终在反复权衡之下，决定获取属性时立即reflow。</p>\n<h3>关于repaint</h3>\n<p>repaint的本质就是重新根据分层信息计算了绘制指令。</p>\n<p>当改动了可见样式后，就需要重新计算，触发repaint流程。</p>\n<p>由于元素的布局信息也属于可见样式，所以reflow一定会引起repaint</p>\n",
            "url": "https://clark-cui.top/posts/浏览器渲染原理.html",
            "title": "浏览器渲染原理",
            "date_modified": "2024-02-29T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h1>爬虫核心</h1>\n<h3>1. HTTP协议</h3>\n<blockquote>\n<p>爬虫就是模拟浏览器去服务器获取数据这一过程的程序</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>请求首行</strong></p>\n<p>(POST /api/v1/auth/password/login?password=123 HTTP/1.1)</p>\n<p><u>请求方法+请求路径+query参数+http协议版本</u></p>\n</li>\n<li>\n<p><strong>请求头</strong></p>\n<p>（Content-Type: application/json\\r\\nUser-Agent: xxx...）</p>\n</li>\n<li>\n<p><strong>请求体</strong></p>\n<p>(空行之后的数据)</p>\n</li>\n<li>\n<p><strong>响应首行</strong></p>\n<p>(HTTP1.1 200 ok)</p>\n<p><u>http协议版本+响应状态码+状态信息</u></p>\n</li>\n<li>\n<p><strong>响应头</strong></p>\n<p>（同请求头）</p>\n</li>\n<li>\n<p><strong>响应体</strong></p>\n<p>(空行之后的数据)</p>\n</li>\n</ul>\n<h3>2. 反反爬策略</h3>\n<blockquote>\n<p>常见的反爬策略是通过区分请求头来鉴别爬虫程序和浏览器正常访问的</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>补User-Agent</strong></p>\n</li>\n<li>\n<p><strong>补Referer</strong></p>\n<p>(防盗链通常校验这个值)</p>\n</li>\n<li>\n<p><strong>补Cookie</strong></p>\n<p>(需要登陆的网站通常需要校验Cookie)</p>\n</li>\n<li>\n<p><strong>补加密参数（重点）</strong></p>\n<p>(一些网站会把请求参数做某种加密，在服务端进行解密验证，我们需要逆向出对应的加密方式，并进行模拟)</p>\n</li>\n</ul>\n<h3>3. 常见加密方式</h3>\n<blockquote>\n<p>常见的加密方式有base64转码、md5摘要、aes对称加密、rsa非对称加密等</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>base64转码</strong></p>\n<p>base64包括的字符有大写字母 A-Z、小写字母 a-z、数字 0-9、符号 &quot;+&quot;、&quot;/&quot;（再加上作为垫字的 &quot;=&quot;，实际上是 65 个字符)</p>\n</li>\n<li>\n<p><strong>md5摘要</strong></p>\n<p>md5全称Message Digest Algorithmn，是一种被广泛使用的密码散列函数，它可以产生出一个 128 bit 的散列值（hash value），用于确保信息传输完整一致。常见的md5摘要分为<u>取16位和取32位两种格式</u>（都是从同一组数据中取的）。从严格意义上来说，md5不是一种加密方式，而是一种摘要方式，<u>它的过程是不可逆的</u>，类似的摘要方式还有md2、md4、hmac-md5、sha等</p>\n</li>\n<li>\n<p><strong>aes对称加密</strong></p>\n<p>对称加密是指可以用同一个密钥将数据进行加密和解密的加密方式，类似的加密方式还有des</p>\n</li>\n<li>\n<p><strong>rsa非对称加密</strong></p>\n<p>非对称加密是指必须用两个不同的密钥（公钥和私钥，公钥用于加密数据，私钥用于解密数据）将数据进行加密和解密的加密方式</p>\n</li>\n</ul>\n<h3>4. 关于补加密参数</h3>\n<blockquote>\n<p>补加密参数的过程，就是我们所说的js逆向的过程。它的目标是：通过一些调试手段(常见的像chrome devtools中的断点调试、函数跟栈、全局搜索)拿到网站中生成的加密参数值或者生成加密参数的代码，让其运行在本地的爬虫程序中，从而达到绕过浏览器直接向服务器获取数据的目的。</p>\n</blockquote>\n<p>我们可以根据一些常见的加密方式特征逆向出该加密方式，</p>\n<p>常见的像md5的魔法值：</p>\n<p><u>1732584193</u>、<u>1732584194</u>、<u>271733878</u>、<u>271733879</u>（十进制）</p>\n<p><u>0x67452301</u>、<u>0x98badcfe</u>、<u>0x10325476</u>、<u>0xefcdab89</u>（十六进制）</p>\n",
            "url": "https://clark-cui.top/posts/爬虫核心.html",
            "title": "爬虫核心",
            "date_modified": "2024-02-29T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h1>测试一下呢呢</h1>\n<p>测试测试</p>\n<pre><code class=\"language-javascript\">console.log('test test')\n</code></pre>\n",
            "url": "https://clark-cui.top/posts/作为测试文章.html",
            "title": "测试文章",
            "summary": "测试测试",
            "date_modified": "2024-02-15T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        }
    ]
}