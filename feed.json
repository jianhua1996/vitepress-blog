{
    "version": "https://jsonfeed.org/version/1",
    "title": "Clark Cui",
    "home_page_url": "https://clark-cui.top/",
    "feed_url": "https://clark-cui.top/feed.json",
    "description": "Clark Cui' Blog",
    "icon": "https://clark-cui.top/horse.svg",
    "author": {
        "name": "Clark Cui",
        "url": "https://clark-cui.top"
    },
    "items": [
        {
            "content_html": "<h2>浏览器渲染管线</h2>\n<h3>5 绘制（Painting）</h3>\n<p>绘制发生在主线程 ​​，目标是将布局树中的元素转换为<strong>绘制指令列表（Paint Records）</strong> ​​，为后续的合成阶段提供数据支持。</p>\n<pre><code class=\"language-mermaid\">flowchart LR\n  A[布局树] --&gt; B[生成绘制指令]\n  B --&gt; C[光栅化]\n  C --&gt; D[位图数据]\n  D --&gt; E[合成线程处理]\n</code></pre>\n<p><strong>关键步骤说明</strong>：</p>\n<ul>\n<li><strong>生成绘制指令</strong>：主线程遍历布局树，为每个元素生成 <strong>绘制指令列表（Paint Records）</strong>，描述其颜色、背景、边框、文本等视觉属性。</li>\n<li><strong>按层划分任务</strong>：每个合成层（Compositing Layer）独立生成绘制指令，避免跨层混合。</li>\n<li><strong>提交至合成线程</strong>：主线程将绘制指令和图层信息传递给合成线程，完成后续处理。</li>\n</ul>\n<blockquote>\n<p>注意：绘制指令是一种底层的、描述如何渲染元素的抽象操作列表，实际由浏览器引擎生成。我们可以暂时理解为类似 <code>canvas api</code> 的指令集。</p>\n</blockquote>\n<h4>5.1. 绘制指令类型</h4>\n<table>\n<thead>\n<tr>\n<th>指令类型</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>fillRect</code></td>\n<td>填充矩形区域</td>\n<td>背景颜色、边框</td>\n</tr>\n<tr>\n<td><code>drawText</code></td>\n<td>绘制文本</td>\n<td>字体、颜色、阴影</td>\n</tr>\n<tr>\n<td><code>drawImage</code></td>\n<td>绘制图像</td>\n<td>背景图片、图标</td>\n</tr>\n<tr>\n<td><code>drawBorder</code></td>\n<td>绘制边框</td>\n<td>边框样式、圆角</td>\n</tr>\n<tr>\n<td><code>drawShadow</code></td>\n<td>绘制阴影</td>\n<td>文本阴影、盒阴影</td>\n</tr>\n</tbody>\n</table>\n<h4>5.2 绘制状态管理</h4>\n<p>绘制过程中，浏览器会维护 <strong>绘制状态栈</strong>，通过 <code>save()</code>（保存当前颜色、字体、变换等状态）和 <code>restore()</code>（恢复上一次保存的状态）管理指令上下文，避免不同元素的绘制属性相互干扰。</p>\n<h4>5.3. 绘制顺序规则</h4>\n<table>\n<thead>\n<tr>\n<th>因素</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>文档流顺序</td>\n<td>默认从上到下、从左到右绘制</td>\n</tr>\n<tr>\n<td>堆叠上下文与 z-index</td>\n<td>不同堆叠上下文的元素按 <code>z-index</code> 排序，同一上下文内按 CSS 层叠规则排序</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>同一上下文内的绘制顺序见上篇文章：<a href=\"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89#_4-1-1-%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F\">浏览器渲染原理（二）- 层叠上下文绘制顺序</a></li>\n</ul>\n<h4>5.4. 触发重绘的操作</h4>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>是否触发重绘</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>修改颜色、背景</td>\n<td>✅</td>\n<td>如 <code>element.style.backgroundColor = 'red'</code></td>\n</tr>\n<tr>\n<td>修改字体大小</td>\n<td>✅</td>\n<td>如 <code>element.style.fontSize = '20px'</code></td>\n</tr>\n<tr>\n<td>修改 transform</td>\n<td>❌（特定场景）</td>\n<td>仅当元素已升级为合成层时，直接由合成线程处理</td>\n</tr>\n<tr>\n<td>修改 opacity</td>\n<td>❌（特定场景）</td>\n<td>仅当元素已升级为合成层时，直接由合成线程处理</td>\n</tr>\n</tbody>\n</table>\n<h4>5.5. 绘制指令的优化</h4>\n<p><strong>优化策略</strong>：</p>\n<p>todo: 待补充，见 <a href=\"https://web.dev/articles/howbrowserswork?hl=zh-cn#painting\">how browsers work</a></p>\n",
            "url": "https://clark-cui.top/posts/浏览器渲染原理（三）.html",
            "title": "浏览器渲染原理（三）",
            "date_modified": "2025-08-23T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>浏览器渲染管线</h2>\n<h3>3. 布局阶段 (Layout / Reflow)</h3>\n<p>布局阶段是将样式计算结果转换为精确几何尺寸的过程，其核心目标是确定每个可见元素在屏幕上的<strong>位置</strong>和<strong>大小</strong>。</p>\n<h4>3.1. 构建布局树（Layout Tree Construction）</h4>\n<p>布局树是对渲染树的几何属性（位置、尺寸）计算后生成的树结构，仅包含需参与几何计算的可见节点：</p>\n<pre><code class=\"language-mermaid\">  flowchart LR\n    X[DOM树] --&gt; A[过滤不可见节点]\n    Y[CSSOM树] --&gt; A\n    A --&gt; B[处理伪元素]\n    B--&gt; C{渲染树}\n    C1{渲染树} --&gt; D[创建布局对象]\n    D --&gt; E[处理匿名盒模型]\n    E--&gt; F[几何属性计算]\n    F --&gt; G{布局树}\n</code></pre>\n<p><strong>关键步骤说明</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>操作细节</th>\n<th>关键说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>过滤不可见节点 <strong>（在渲染树构建阶段已完成）</strong></td>\n<td>移除 <code>display: none</code> 的元素；保留 <code>visibility: hidden</code>（占据空间但不可见）</td>\n<td><code>visibility: hidden</code> 仍参与布局计算</td>\n</tr>\n<tr>\n<td>创建布局对象</td>\n<td>为可见元素生成布局对象（LayoutObject），包含样式信息和初始几何属性</td>\n<td>布局对象与 DOM 节点不完全一一对应（如相邻文本节点可能合并）</td>\n</tr>\n<tr>\n<td>处理匿名盒模型</td>\n<td>补全混合内容流的布局层级（如块级容器内的内联内容）</td>\n<td>解决 CSS 盒模型规则下的内容排列问题（见下表示例）</td>\n</tr>\n<tr>\n<td>计算几何属性</td>\n<td>根据样式信息计算几何属性（如<code>width/height</code>、<code>margin/padding</code>、<code>position</code>）</td>\n<td>依赖<strong>包含块</strong>（元素布局的参考坐标系）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>匿名盒模型示例</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>匿名盒类型</th>\n<th>产生场景</th>\n<th>示例 HTML</th>\n<th>布局结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>匿名块盒</td>\n<td>块级容器中混合块级元素和内联内容</td>\n<td><code>&lt;div&gt;文本&lt;span&gt;内联&lt;/span&gt;&lt;p&gt;块级&lt;/p&gt;更多文本&lt;/div&gt;</code></td>\n<td>生成包含&quot;文本&quot;和&quot;更多文本&quot;的两个匿名块盒，与<code>&lt;p&gt;</code>块级元素垂直排列</td>\n</tr>\n<tr>\n<td>匿名行盒</td>\n<td>块级容器中仅包含内联内容</td>\n<td><code>&lt;p&gt;这是一段需要换行的文本&lt;/p&gt;</code></td>\n<td>文本被包裹在匿名行盒中，根据容器宽度自动换行</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>注意</strong>：匿名盒无法通过 JavaScript 直接访问，但会影响布局计算（如边距折叠、行高计算）。参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_display/Visual_formatting_model#%E7%9B%92%E5%AD%90%E7%94%9F%E6%88%90\">MDN 匿名盒</a></p>\n</blockquote>\n<h4>3.2. 布局计算（Layout Computation）</h4>\n<p>布局计算的核心是为布局树中的每个节点计算精确的宽度、高度、位置（top/left/right/bottom），依赖<strong>包含块</strong>（元素布局的参考坐标系）。</p>\n<h5>3.2.1. 包含块的确定规则</h5>\n<table>\n<thead>\n<tr>\n<th>元素定位类型</th>\n<th>包含块规则</th>\n<th>例外情况（触发新包含块的祖先属性）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>static/relative/sticky</code></td>\n<td>由最近的块级祖先元素的<strong>内容盒（content box）</strong> 创建</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>absolute</code></td>\n<td>由最近的非<code>static</code>定位祖先元素的<strong>内边距盒（padding box）</strong> 创建；无则用初始包含块</td>\n<td>祖先满足以下任一条件：<br>1. <code>transform/perspective</code> ≠ <code>none</code><br>2. <code>will-change: transform/perspective</code><br>3. <code>filter</code> ≠ <code>none</code> 或者 <code>will-change: filter</code>（Firefox） <br>4. <code>contain: layout/paint/strict/content</code> <br>5. <code>backdrop-filter</code> ≠ <code>none</code>（有争议）</td>\n</tr>\n<tr>\n<td><code>fixed</code></td>\n<td>默认由视口（viewport）或分页媒体的分页区域创建</td>\n<td>同上（<code>transform</code>等属性会改变包含块）</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>参考：<br>- <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_display/Containing_block\">MDN 包含块</a><br>- <a href=\"https://www.w3.org/TR/css-position-3/#containing-block\">W3C CSS Positioned Layout</a></p>\n</blockquote>\n<h5>3.2.2. 几何属性计算顺序与特殊布局</h5>\n<p>布局计算以&quot;包含块&quot;为单位递归：先计算父包含块的几何属性，再基于此计算子元素的位置与尺寸，整体遵循&quot;从包含块到子元素&quot;的依赖顺序</p>\n<table>\n<thead>\n<tr>\n<th>计算内容</th>\n<th>依赖因素</th>\n<th>特殊布局模式的影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>宽度/高度</td>\n<td><code>width/height</code>、<code>padding</code>、<code>border</code>、<code>margin</code>、内容尺寸（如<code>width: auto</code>自适应）</td>\n<td>块级格式化上下文（BFC）会垂直排列元素并合并边距；弹性布局（Flexbox）按主轴分配空间</td>\n</tr>\n<tr>\n<td>位置（top/left）</td>\n<td>包含块的左上角坐标 + 自身定位属性（如<code>position: absolute</code>的<code>left: 10px</code>）</td>\n<td>浮动布局（Float）会脱离文档流，父元素可能高度塌陷；网格布局（Grid）按轨道对齐</td>\n</tr>\n</tbody>\n</table>\n<p><strong>特殊布局模式对比</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>布局模式</th>\n<th>核心特性</th>\n<th>典型应用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>块级格式化上下文（BFC）</td>\n<td>垂直排列元素、合并边距、包含浮动元素</td>\n<td>防止浮动父元素高度塌陷（<code>overflow: hidden</code>触发 BFC）</td>\n</tr>\n<tr>\n<td>弹性布局（Flexbox）</td>\n<td>主轴/交叉轴空间分配、弹性因子、对齐控制</td>\n<td>一维布局（导航栏、卡片列表）</td>\n</tr>\n<tr>\n<td>网格布局（Grid）</td>\n<td>二维轨道划分、隐式网格创建、对齐控制</td>\n<td>复杂二维布局（仪表盘、网格图库）</td>\n</tr>\n<tr>\n<td>浮动布局（Float）</td>\n<td>元素脱离文档流、文字环绕、父元素高度塌陷</td>\n<td>多列布局（传统新闻网站）</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>参考：<br>- <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_display/Block_formatting_context\">MDN 块级格式化上下文</a><br>- <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout\">MDN 弹性布局</a><br>- <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_grid_layout\">MDN 网格布局</a><br>- <a href=\"https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/CSS_layout/Floats\">MDN 浮动布局</a></p>\n</blockquote>\n<h4>3.3. 增量布局与性能优化</h4>\n<p>为避免全量重排（Full Reflow），浏览器采用<strong>增量布局</strong>策略，仅更新受影响的子树。</p>\n<p><strong>增量布局机制（Incremental Layout）</strong>：</p>\n<pre><code class=\"language-mermaid\">  flowchart LR\n  A[DOM修改] --&gt; B[标记'脏'节点]\n  B --&gt; C{是否在布局边界内？}\n  C --&gt;|是| D[局部重排]\n  C --&gt;|否| E[整树重排]\n</code></pre>\n<p><strong>关键规则</strong>：</p>\n<ul>\n<li><strong>脏节点</strong>：当 DOM 结构、样式或几何属性发生变化时，可能需要重建布局树。</li>\n<li><strong>布局边界</strong>：父节点的布局范围限制（如<code>overflow: hidden</code>的容器会截断子节点的重排影响）。</li>\n</ul>\n<blockquote>\n<p>参考：<a href=\"https://web.dev/articles/howbrowserswork?hl=zh-cn#layout\">Web Dev howbrowserswork</a></p>\n</blockquote>\n<p><strong>避免布局抖动（Layout Thrashing）</strong>：</p>\n<pre><code class=\"language-javascript\">// 错误示例：连续交叉读写布局属性导致触发多次重排\n// 步骤1：写操作（修改width）\nelement.style.width = '100px'\n// 浏览器：暂存这个修改，标记为脏节点，不立即布局\n\n// 步骤2：读操作（获取offsetWidth）\nconst width = element.offsetWidth\n// 浏览器：必须返回最新宽度，所以强制执行步骤1的布局计算（第一次布局）\n\n// 步骤3：写操作（修改height）\nelement.style.height = '200px'\n// 浏览器：暂存这个修改，标记为脏节点，等待下一次布局时机\n</code></pre>\n<ul>\n<li><strong>后果</strong>：每次读操作都会触发浏览器立即执行重排，导致性能损耗。</li>\n<li><strong>优化</strong>：</li>\n</ul>\n<pre><code class=\"language-javascript\">// 读写分离：先批量读，再批量写；或者先批量写，再批量读\nrequestAnimationFrame(() =&gt; {\n\t// 1. 先读后写（推荐）\n\t// 先执行读操作（获取当前布局信息，利用缓存，无强制同步布局）\n\tconst width = element.offsetWidth\n\t// 再执行所有写操作（批量暂存）\n\telement.style.width = '100px'\n\telement.style.height = '200px'\n\n\t// 2. 先写后读\n\t// 先执行所有写操作（批量暂存）\n\telement.style.width = '100px'\n\telement.style.height = '200px'\n\t// 最后执行读操作（依然会触发一次强制同步布局）\n\tconst width = element.offsetWidth\n})\n</code></pre>\n<p><strong>关键结论</strong>：<br>\n连续的多次读操作（中间无写操作）是安全的，浏览器会通过缓存机制优化，不会重复计算布局，性能开销很小。<br>\n<strong>真正需要避免的是 “写 - 读 - 写”“读 - 写 - 读” 这类读写交替的操作，它们会频繁打破浏览器的优化机制，导致多次布局计算</strong>。</p>\n<h3>4. 分层阶段（Layer Stage）</h3>\n<p>分层阶段的目标是将布局树中的元素分配到不同的渲染层（Render Layers），通过隔离动态内容、复用静态内容提升渲染效率。</p>\n<h4>4.1. 分层触发条件</h4>\n<p>渲染层的拆分通常与层叠上下文（Stacking Context）密切相关，而层叠上下文的实际触发条件如下：</p>\n<table>\n<thead>\n<tr>\n<th>触发类型</th>\n<th>具体条件</th>\n<th>示例 HTML/CSS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>默认分层</td>\n<td>文档根元素（<code>&lt;html&gt;</code>）</td>\n<td><code>&lt;html&gt;...&lt;/html&gt;</code></td>\n</tr>\n<tr>\n<td>定位与堆叠</td>\n<td>- <code>position: absolute/relative</code>且<code>z-index ≠ auto</code><br> - <code>position: fixed/sticky</code><br>- flex/grid 容器的子元素且 <code>z-index ≠ auto</code></td>\n<td><code>&lt;div style=&quot;position: absolute; z-index: 10;&quot;&gt;&lt;/div&gt;</code></td>\n</tr>\n<tr>\n<td>视觉效果属性</td>\n<td>- <code>opacity &lt; 1</code><br>- <code>mix-blend-mode ≠ normal</code><br>- <code>transform/perspective/filter/backdrop-filter/clip-path/mask ≠ none</code></td>\n<td><code>&lt;div style=&quot;transform: translateZ(0);&quot;&gt;&lt;/div&gt;</code>（触发 GPU 加速）</td>\n</tr>\n<tr>\n<td>媒体与插件</td>\n<td><code>&lt;video&gt;</code>、<code>&lt;canvas&gt;</code>、<code>&lt;iframe&gt;</code>、WebGL 上下文</td>\n<td><code>&lt;video src=&quot;video.mp4&quot; controls&gt;&lt;/video&gt;</code></td>\n</tr>\n<tr>\n<td>溢出与滚动</td>\n<td><code>overflow: auto/scroll</code>且内容超出容器尺寸（产生实际滚动条）</td>\n<td><code>&lt;div style=&quot;overflow: auto; height: 300px;&quot;&gt;长内容...&lt;/div&gt;</code></td>\n</tr>\n<tr>\n<td>主动提示</td>\n<td>- <code>will-change: 可触发分层的属性</code>（如<code>transform</code>、<code>opacity</code>）<br>- <code>contain: layout/paint/strict/content</code></td>\n<td><code>&lt;div style=&quot;will-change: transform;&quot;&gt;&lt;/div&gt;</code>（预优化动画元素）</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>参考： <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_positioned_layout/Stacking_context\">MDN 层叠上下文</a></p>\n</blockquote>\n<h5>4.1.1 层叠上下文绘制顺序</h5>\n<table>\n<thead>\n<tr>\n<th>顺序</th>\n<th>绘制内容</th>\n<th>详细说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>自身背景与边框</strong></td>\n<td>层叠上下文元素的背景和边框最先绘制</td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td><strong>负 z-index 子层叠上下文</strong></td>\n<td>递归处理所有<code>z-index &lt; 0</code>的子层叠上下文<br>（按 z-index 升序，同值按 DOM 顺序）</td>\n</tr>\n<tr>\n<td><strong>3</strong></td>\n<td><strong>文档流内容</strong></td>\n<td>按顺序绘制：<br>1. 块级元素（背景/边框）<br>2. 浮动元素<br>3. 行内元素（含文本装饰）</td>\n</tr>\n<tr>\n<td><strong>4</strong></td>\n<td><strong>z-index:auto/0 的定位元素</strong></td>\n<td>绘制定位元素及其内容<br>（若创建新层叠上下文则递归处理）</td>\n</tr>\n<tr>\n<td><strong>5</strong></td>\n<td><strong>正 z-index 子层叠上下文</strong></td>\n<td>递归处理所有<code>z-index &gt;= 1</code>的子层叠上下文<br>（按 z-index 升序，同值按 DOM 顺序）</td>\n</tr>\n<tr>\n<td><strong>6</strong></td>\n<td><strong>轮廓(outline)</strong></td>\n<td>最后绘制所有元素的轮廓线</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>特殊说明（根层叠上下文差异）</strong>：</p>\n<ul>\n<li><strong>根元素背景</strong>：仅根层叠上下文需要先绘制整个画布背景</li>\n<li><strong>绘制范围</strong>：根层叠上下文的背景覆盖无限画布，普通层叠上下文的背景限定在元素边界内</li>\n</ul>\n<p>参考：<a href=\"https://www.w3.org/TR/CSS2/zindex.html#painting-order\">w3c 层叠上下文的详细描述</a></p>\n</blockquote>\n<h5>4.1.2 层叠上下文绘制示例</h5>\n<pre><code class=\"language-html\">&lt;div\n\tclass=&quot;A&quot;\n\tstyle=&quot;position: relative; z-index: 1&quot;\n&gt;\n\t&lt;!-- 层叠上下文 --&gt;\n\t背景A\n\t&lt;div\n\t\tclass=&quot;B&quot;\n\t\tstyle=&quot;position: absolute; z-index: -1&quot;\n\t&gt;\n\t\t&lt;!-- 负z-index子上下文 --&gt;\n\t\t背景B（递归步骤2）\n\t\t&lt;div\n\t\t\tclass=&quot;C&quot;\n\t\t\tstyle=&quot;opacity: 0.8&quot;\n\t\t&gt;\n\t\t\t&lt;!-- 隐式层叠上下文 --&gt;\n\t\t\t内容C（在B的递归中处理）\n\t\t&lt;/div&gt;\n\t&lt;/div&gt;\n\t&lt;div\n\t\tclass=&quot;D&quot;\n\t\tstyle=&quot;float: left&quot;\n\t&gt;\n\t\t浮动元素（步骤3）\n\t&lt;/div&gt;\n\t&lt;div\n\t\tclass=&quot;E&quot;\n\t\tstyle=&quot;position: absolute; z-index: 0&quot;\n\t&gt;\n\t\t&lt;!-- z-index:0 --&gt;\n\t\t内容E（步骤4）\n\t&lt;/div&gt;\n\t&lt;div\n\t\tclass=&quot;F&quot;\n\t\tstyle=&quot;position: absolute; z-index: 2&quot;\n\t&gt;\n\t\t&lt;!-- 正z-index子上下文 --&gt;\n\t\t背景F（递归步骤5）\n\t&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p><strong>递归绘制顺序详解</strong>：</p>\n<ol>\n<li>绘制 A 的背景和边框</li>\n<li>递归处理 B（负 z-index 子上下文）：\n<ul>\n<li>绘制 B 的背景和边框</li>\n<li>递归处理 C（opacity 创建的隐式层叠上下文）：\n<ul>\n<li>绘制 C 的背景和边框</li>\n<li>绘制 C 的文档流内容</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>绘制 A 的文档流内容：\n<ul>\n<li>块级元素</li>\n<li>浮动元素 D</li>\n<li>行内元素</li>\n</ul>\n</li>\n<li>绘制定位元素 E（z-index:0）及其内容</li>\n<li>递归处理 F（正 z-index 子上下文）：\n<ul>\n<li>绘制 F 的背景和边框</li>\n<li>绘制 F 的内容</li>\n</ul>\n</li>\n<li>绘制所有元素的外轮廓(outline)</li>\n</ol>\n<blockquote>\n<p><strong>关键特点</strong>：</p>\n<ol>\n<li><strong>层级隔离</strong>：每个子层叠上下文独立绘制，不受外部 z-index 影响</li>\n<li><strong>深度优先递归</strong>：遇到子层叠上下文时立即展开处理</li>\n<li><strong>位置决定顺序</strong>：\n<ul>\n<li>负 z-index 内容在父背景后、文档流前</li>\n<li>正 z-index 内容在文档流后、轮廓前</li>\n</ul>\n</li>\n<li><strong>创建方式无关</strong>：无论通过 z-index/opacity/transform 等何种方式创建，绘制规则一致</li>\n</ol>\n</blockquote>\n<h4>4.2. 渲染层与合成层的层级关系</h4>\n<p>分层并非单一层级，而是存在&quot;渲染层 → 合成层&quot;的升级关系：</p>\n<pre><code class=\"language-mermaid\">  graph TD\n  A[布局树] --&gt; B(渲染层 RenderLayer)\n  B --&gt; C{满足合成条件?}\n  C --&gt;|是| D[合成层 CompositingLayer]\n  C --&gt;|否| E[合并到父合成层]\n  D --&gt; F[GPU纹理]\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>层级类型</th>\n<th>特性与优化</th>\n<th>典型场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>渲染层</td>\n<td>存储绘制指令，管理层叠顺序</td>\n<td>静态文本块、无动画的按钮</td>\n</tr>\n<tr>\n<td>合成层</td>\n<td>独立 GPU 纹理、由合成线程直接处理、支持 GPU 加速动画</td>\n<td>动画元素（<code>transform: translate</code>）、半透明浮层（<code>opacity: 0.8</code>）</td>\n</tr>\n</tbody>\n</table>\n<h4>4.3. 层的堆叠与排序</h4>\n<p>层叠顺序由<strong>层叠上下文</strong>决定，子层无法超出父层的堆叠范围。</p>\n<ul>\n<li>见本文 → <a href=\"#_4-1-1-%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F\">4.1.1 层叠上下文绘制顺序</a>。</li>\n</ul>\n<h4>4.4. 层的优化策略</h4>\n<p>浏览器通过合并与拆分层平衡内存与性能：</p>\n<table>\n<thead>\n<tr>\n<th>优化操作</th>\n<th>触发条件</th>\n<th>性能影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>层合并</td>\n<td>同层级且无重叠的静态层</td>\n<td>减少 GPU 内存占用，降低合成开销</td>\n</tr>\n<tr>\n<td>层拆分（瓦片化）</td>\n<td>大尺寸层（如长列表）、超出视口的层</td>\n<td>拆分为 256x256 瓦片，仅光栅化可视区域，减少内存占用</td>\n</tr>\n<tr>\n<td>层提升（Promote）</td>\n<td>动画元素（<code>transform/opacity</code>）、频繁重绘的元素</td>\n<td>提升至合成层，避免触发重排重绘</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>最佳实践</strong>：对动画元素使用<code>transform</code>替代<code>top/left</code>，触发合成层以提升性能。</p>\n</blockquote>\n",
            "url": "https://clark-cui.top/posts/浏览器渲染原理（二）.html",
            "title": "浏览器渲染原理（二）",
            "date_modified": "2025-07-27T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>浏览器的多进程架构</h2>\n<h3>进程与线程</h3>\n<p><strong>进程</strong>：<br>\n指计算机中已执行的程序，曾经是分时系统的基本运作单位。在面向进程设计的系统中，是程序的基本执行实体；在面向线程设计的系统中，进程本身不是基本执行单位，而是线程的容器。<br>\n<strong>线程</strong>：<br>\n进程内的执行单元，是 CPU 调度的基本单位。</p>\n<p>参考：<a href=\"https://zh.wikipedia.org/zh-cn/%E8%A1%8C%E7%A8%8B\">进程</a>、<a href=\"https://zh.wikipedia.org/zh-cn/%E7%BA%BF%E7%A8%8B\">线程</a></p>\n<h3>现代浏览器的进程架构</h3>\n<p>Chrome 为代表的现代浏览器采用多进程架构，主要进程类型包括：</p>\n<table>\n<thead>\n<tr>\n<th>进程类型</th>\n<th>职责</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>浏览器主进程</td>\n<td>管理界面、存储、下载等核心功能</td>\n</tr>\n<tr>\n<td>GPU 进程</td>\n<td>处理图形渲染任务</td>\n</tr>\n<tr>\n<td>网络进程</td>\n<td>管理网络请求和响应</td>\n</tr>\n<tr>\n<td>存储进程</td>\n<td>处理缓存和存储操作</td>\n</tr>\n<tr>\n<td><strong>渲染进程</strong></td>\n<td><strong>核心：将 HTML/CSS/JS 转换为可交互页面</strong></td>\n</tr>\n<tr>\n<td>插件进程</td>\n<td>管理第三方插件</td>\n</tr>\n</tbody>\n</table>\n<p>下面是浏览器的实际进程截图：</p>\n<ImageBuilder :source=\"['浏览器进程架构.png']\" size=\"medium\"/>\n<p>其中，<strong>渲染进程</strong>是我们最应该关注的进程，它负责通过一系列渲染步骤（又称作浏览器渲染管线）将 HTML、JavaScript、CSS、图片等资源最终解析为可以显示和交互的页面。</p>\n<p><strong>渲染进程管理规则</strong>：</p>\n<pre><code class=\"language-mermaid\">  flowchart TD\n  A[新页面请求] --&gt; B{与当前页面是否同站？}\n  B --&gt;|是| C[复用当前渲染进程]\n  B --&gt;|否| D[创建新渲染进程]\n</code></pre>\n<ul>\n<li>同站判定：相同的 eTLD+1（有效顶级域名+二级域名）</li>\n<li>示例：\n<ul>\n<li>✅ <code>www.baidu.com</code>与<code>tieba.baidu.com</code> → 同站</li>\n<li>❌ <code>www.baidu.com</code>与<code>www.taobao.com</code> → 不同站</li>\n</ul>\n</li>\n</ul>\n<p>如下图所示：<br>\n<ImageBuilder :source=\"['浏览器进程架构-同站进程复用1.png','浏览器进程架构-同站进程复用2.png','浏览器进程架构-同站进程复用3.png']\" size=\"medium\" /></p>\n<blockquote>\n<p>判断 eTLD+1 的方法依赖于公共后缀列表（Public Suffix List），参考<a href=\"https://publicsuffix.org/list/\">公共后缀列表</a></p>\n<p>多进程架构的优势：崩溃隔离，沙箱化等，参考<a href=\"https://developer.chrome.com/blog/inside-browser-part1?hl=zh-cn#the_benefit_of_multi-process_architecture_in_chrome\">Chrome 中多进程架构的好处</a></p>\n</blockquote>\n<hr>\n<h2>浏览器渲染管线</h2>\n<p>我们把从输入数据（通常是 HTML、CSS、JavaScript）到显示结果（屏幕上看到的画面）这整个过程称为浏览器的渲染流程，或者叫渲染管线。</p>\n<p>完整的渲染管线流程：</p>\n<pre><code class=\"language-mermaid\">  flowchart LR\n  A[HTML解析] --&gt; B[样式计算]\n  B --&gt; C[布局]\n  C --&gt; D[分层]\n  D --&gt; E[绘制]\n  E --&gt; F[分块]\n  F --&gt; G[光栅化]\n  G --&gt; H[合成]\n</code></pre>\n<p>这个过程也被称为<a href=\"https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path\">关键渲染路径(Critical Rendering Path)</a>。</p>\n<hr>\n<h3>1. HTML 解析与 DOM 树构建</h3>\n<p>HTML 解析是浏览器渲染管线的第一步，它将 HTML 文档转换为 DOM 树。这个过程遵循<a href=\"https://html.spec.whatwg.org/multipage/parsing.html#parsing\">WHATWG HTML 标准</a>中定义的算法。</p>\n<h4>1.1. 字节流解码（Byte Decoding）</h4>\n<p><strong>目标</strong>：将原始字节流转换为可读字符</p>\n<p><strong>编码识别优先级</strong>：</p>\n<ol>\n<li>🥇<a href=\"https://encoding.spec.whatwg.org/#bom-sniff\">BOM 嗅探</a> （BOM sniffing）最高优先级</li>\n<li>🥈HTTP 头中的<code>Content-Type</code>（如<code>Content-Type: text/html; charset=UTF-8</code>）</li>\n<li>🥉HTML 文档中的 <code>&lt;meta&gt;</code>声明\n<ul>\n<li>对于 HTML5 文档，优先识别<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></li>\n<li>对于旧版 HTML，识别<code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=GBK&quot;&gt;</code></li>\n</ul>\n</li>\n<li>文档关联/资源路径推测\n<blockquote>\n<p><strong>特殊情况</strong>：同时存在 BOM 和 HTTP charset 声明时，<strong>BOM 优先级更高</strong></p>\n</blockquote>\n</li>\n</ol>\n<h4>1.2. 令牌化（Tokenization）</h4>\n<p><strong>目标</strong>：将字符串切割为有意义的语法单元（Tokens）</p>\n<p><strong>分词规则</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>输入</th>\n<th>输出 Token 类型</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;div&gt;</code></td>\n<td>开始标签</td>\n<td><code>StartTag: div</code></td>\n</tr>\n<tr>\n<td><code>&lt;/div&gt;</code></td>\n<td>结束标签</td>\n<td><code>EndTag: div</code></td>\n</tr>\n<tr>\n<td><code>class=&quot;title&quot;</code></td>\n<td>标签属性</td>\n<td>作为开始标签的一部分</td>\n</tr>\n<tr>\n<td><code>Hello World</code></td>\n<td>文本</td>\n<td><code>Text: &quot;Hello World&quot;</code></td>\n</tr>\n<tr>\n<td><code>&lt;!-- comment --&gt;</code></td>\n<td>注释</td>\n<td><code>Comment: &quot;comment&quot;</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>容错机制</strong>：自动修正错误语法（如未闭合标签、错误嵌套）</p>\n<h4>1.3. DOM 树构建（Tree Construction）</h4>\n<p><strong>目标</strong>：将 Token 序列转换为具有层级关系的 DOM（文档对象模型）树</p>\n<p><strong>核心过程</strong>：</p>\n<pre><code class=\"language-mermaid\">  flowchart TB\n  T[Token序列] --&gt; P[开放元素栈]\n  P --&gt; N[创建节点]\n  N --&gt; R[建立父子关系]\n  R --&gt; D[完成DOM树]\n</code></pre>\n<p><strong>关键技术细节</strong>：</p>\n<ul>\n<li>使用<a href=\"https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements\">开放元素栈</a>维护元素的层级关系</li>\n<li><strong>脚本处理规则</strong>：\n<ul>\n<li>遇到<code>&lt;script&gt;</code>时暂停 DOM 构建并执行脚本，如果脚本需要下载，则需要等待脚本下载并执行完成。（除非标记<code>async</code>/<code>defer</code>）\n<blockquote>\n<p>async/defer 的区别，参考： <a href=\"https://zh.javascript.info/script-async-defer#zong-jie\">脚本：async，defer</a></p>\n</blockquote>\n</li>\n<li>特殊行为：调用<code>document.write()</code>会插入内容到当前位置并重启解析</li>\n</ul>\n</li>\n<li><strong>自动补全和纠错</strong>：\n<ul>\n<li>自动补全缺失的<code>&lt;html&gt;</code>/<code>&lt;head&gt;</code>/<code>&lt;body&gt;</code></li>\n<li>纠正错误的嵌套顺序（如<code>&lt;p&gt;</code>内嵌<code>&lt;div&gt;</code>）</li>\n<li>处理未闭合的标签</li>\n</ul>\n</li>\n</ul>\n<h4>1.4. 触发文档就绪事件（Document Readiness）</h4>\n<pre><code class=\"language-mermaid\">  flowchart LR\n  DOM完成 --&gt; 执行defer脚本 --&gt; DOMContentLoaded\n  DOMContentLoaded --&gt; 等待所有外部资源加载完成 --&gt; load\n</code></pre>\n<h4>构建过程的核心优化机制</h4>\n<ul>\n<li>\n<p><strong>增量构建（Incremental Build）</strong></p>\n<ul>\n<li>浏览器采用增量构建策略，在解析过程中<strong>分批生成 DOM 节点</strong>（无固定大小阈值），允许用户提前看到部分内容（如文本先显示）</li>\n</ul>\n</li>\n<li>\n<p><strong>预解析扫描器（Preload Scanner）</strong></p>\n<ul>\n<li>主解析器在解析 HTML 文档时，会启动一个轻量级的扫描器（独立线程）提前发现并下载 CSS/JS/图片资源\n<blockquote>\n<p>关于预解析扫描器是否是一个独立的线程，存在争议。但可以肯定的是，预解析扫描器与主解析器之间是并行的。参考<a href=\"https://html.whatwg.com.cn/multipage/parsing.html#active-speculative-html-parser\">HTML 标准</a>。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3>2. 样式计算</h3>\n<p>样式计算是浏览器渲染管线中的关键步骤，它将 DOM 树和 CSS 规则结合生成带有样式的渲染树。此过程遵循<a href=\"https://www.w3.org/TR/css-syntax-3/\">W3C CSS Syntax Level 3</a>和<a href=\"https://www.w3.org/TR/css-cascade-4/\">CSS Cascading and Inheritance Level 4</a>等规范。</p>\n<h4>2.1. CSSOM 树构建</h4>\n<pre><code class=\"language-mermaid\">  flowchart LR\n  CSS文本 --&gt; 字节解码 --&gt; 令牌化 --&gt; 规则解析 --&gt; CSSOM树\n</code></pre>\n<p><strong>关键步骤</strong>：</p>\n<ol>\n<li>\n<p><strong>CSS 解析器初始化</strong></p>\n<ul>\n<li>创建样式表对象（CSSStyleSheet）</li>\n<li>初始化规则列表（CSSRuleList）</li>\n</ul>\n</li>\n<li>\n<p><strong>规则解析</strong>：</p>\n<pre><code class=\"language-javascript\">// CSS 规范定义的规则类型（根据CSS Object Model规范）\ninterface CSSRule {\n\tconst unsigned short      STYLE_RULE = 1;\n\tconst unsigned short      CHARSET_RULE = 2;\n\tconst unsigned short      IMPORT_RULE = 3;\n\tconst unsigned short      MEDIA_RULE = 4;\n\tconst unsigned short      FONT_FACE_RULE = 5;\n\tconst unsigned short      PAGE_RULE = 6;\n\tconst unsigned short      KEYFRAMES_RULE = 7;\n\tconst unsigned short      NAMESPACE_RULE = 10;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>错误处理</strong>：</p>\n<ul>\n<li>根据 <a href=\"https://www.w3.org/TR/css-syntax-3/#error-handling\">CSS Parsing Level 3 规范</a>，跳过无效规则</li>\n<li>保留有效部分继续解析</li>\n</ul>\n</li>\n</ol>\n<h4>2.2. 规则匹配</h4>\n<p><strong>匹配过程</strong>：</p>\n<pre><code class=\"language-mermaid\">  flowchart LR\n  D[DOM节点] --&gt; S[选择器引擎]\n  S --&gt;|从右向左| R[.container &gt; ul &gt; li.item]\n  R --&gt;|先匹配li.item| M[匹配结果]\n</code></pre>\n<p><strong>匹配算法</strong>：</p>\n<ol>\n<li>\n<p><strong>从右向左匹配</strong>：</p>\n<ul>\n<li>先匹配最具体的选择器部分（如.class 或#id）</li>\n<li>再验证祖先关系（如 div .class）</li>\n</ul>\n</li>\n<li>\n<p><strong>选择器特异性计算</strong>：</p>\n<pre><code class=\"language-text\">特异性值 = (a, b, c, d)\na = 来自style属性的规则（存在则为1，否则0）\nb = ID选择器的规则数量\nc = 类/属性/伪类选择器的规则数量\nd = 元素/伪元素选择器的规则数量\n</code></pre>\n</li>\n<li>\n<p><strong>规则匹配优化</strong>：</p>\n<ul>\n<li>对常见选择器模式建立索引（如类选择器 → 元素列表映射）</li>\n<li>采用分层过滤（先匹配具体选择器，再验证祖先关系）</li>\n<li>编译选择器为字节码提升执行效率</li>\n</ul>\n</li>\n</ol>\n<h4>2.3. 层叠顺序计算</h4>\n<p>样式层叠遵循<a href=\"https://www.w3.org/TR/css-cascade-4/#cascading\">CSS Cascading and Inheritance 规范</a>定义的层叠顺序：</p>\n<ol>\n<li>\n<p><strong>来源优先级（升序）</strong>：</p>\n<pre><code class=\"language-text\">用户代理声明（user agent declarations）\n用户普通声明（user normal declarations）\n作者普通声明（author normal declarations）\n作者重要声明（author important declarations）\n用户重要声明（user important declarations）\n</code></pre>\n<blockquote>\n<p>名词解释：用户代理声明，浏览器厂商提供的默认样式（即浏览器内置样式）；用户声明，浏览网站的用户定义的样式（比如通过插件书写的样式）；作者声明，由网站开发者编写的 CSS 样式，包括内联样式、嵌入样式、外部样式。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>特异性比较</strong>：</p>\n<ul>\n<li>比较<code>(a,b,c,d)</code>元组，从左到右比较数值</li>\n<li>例如：<code>(1,0,0,0) &gt; (0,2,3,0)</code></li>\n</ul>\n</li>\n<li>\n<p><strong>出现顺序</strong>：</p>\n<ul>\n<li>特异性相同的规则，后出现的覆盖先出现的</li>\n</ul>\n</li>\n</ol>\n<h4>2.4. 继承属性处理</h4>\n<p><strong>继承机制</strong>：</p>\n<pre><code class=\"language-mermaid\">  flowchart TD\n  父元素 --可继承属性--&gt; 子元素\n  子元素 --显式设置--&gt; 覆盖值\n</code></pre>\n<p><strong>关键规则</strong>：</p>\n<ol>\n<li>\n<p><strong>继承值计算</strong>：</p>\n<p>根据 <a href=\"https://www.w3.org/TR/css-cascade-4/#inheriting\">CSS Cascading and Inheritance 规范</a>：</p>\n<pre><code class=\"language-javascript\">// 如果属性是可继承属性，则使用父元素值，否则使用初始值\nif (property.isInherited) {\n\tcomputedValue = parent.computedValue\n} else {\n\tcomputedValue = initialValue\n}\n</code></pre>\n</li>\n<li>\n<p><strong>特殊关键字</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>行为</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>inherit</code></td>\n<td>强制继承父元素值</td>\n</tr>\n<tr>\n<td><code>initial</code></td>\n<td>使用规范初始值</td>\n</tr>\n<tr>\n<td><code>unset</code></td>\n<td>自动继承或初始值</td>\n</tr>\n<tr>\n<td><code>revert</code></td>\n<td>回滚到 UA 样式</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n<h4>2.5. 相对值转换</h4>\n<table>\n<thead>\n<tr>\n<th>相对单位</th>\n<th>转换依据</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>em</td>\n<td>- 用于普通属性时，相对于本元素的字体大小 <br> - 用于 <code>font-size</code> 时相对于父元素的字体大小</td>\n<td></td>\n</tr>\n<tr>\n<td>rem</td>\n<td>根元素 <code>font-size</code></td>\n<td>1rem = 根元素的 <code>font-size</code> 值</td>\n</tr>\n<tr>\n<td>%</td>\n<td>包含块尺寸</td>\n<td><code>width: 50%</code></td>\n</tr>\n<tr>\n<td>vw, vh</td>\n<td>视口尺寸</td>\n<td>1vw = 1%视口宽度</td>\n</tr>\n<tr>\n<td>ch, ex</td>\n<td>字符尺寸</td>\n<td>基于当前字体</td>\n</tr>\n<tr>\n<td>calc()</td>\n<td>数学表达式计算</td>\n<td><code>calc(100% - 20px)</code></td>\n</tr>\n</tbody>\n</table>\n<h4>2.6. 属性值标准化</h4>\n<p><strong>标准化操作</strong>：</p>\n<ol>\n<li>\n<p><strong>简写属性展开</strong>：</p>\n<pre><code class=\"language-css\">/* 输入 */\nmargin: 10px;\n/* 展开为 */\nmargin-top: 10px;\nmargin-right: 10px;\nmargin-bottom: 10px;\nmargin-left: 10px;\n</code></pre>\n</li>\n<li>\n<p><strong>关键字转换</strong>：</p>\n<ul>\n<li>auto → 具体计算值</li>\n<li>currentColor → 解析为当前 color 值</li>\n</ul>\n</li>\n<li>\n<p><strong>规范化值</strong>：</p>\n<ul>\n<li>颜色：RGB() → 十六进制颜色值</li>\n<li>长度：10em → px</li>\n<li>...</li>\n</ul>\n</li>\n</ol>\n<h4>2.7. 媒体查询处理</h4>\n<pre><code class=\"language-mermaid\">  flowchart LR\n  媒体规则 --&gt; 条件检测 --&gt;|匹配| 应用规则\n  条件检测 --&gt;|不匹配| 忽略规则\n</code></pre>\n<h4>2.8. 伪元素/类处理</h4>\n<p><strong>注意</strong>： 伪元素的样式在样式计算阶段确定，但对应的渲染节点在后续渲染树构建时才生成。</p>\n<pre><code class=\"language-mermaid\">  flowchart LR\n  DOM树 --样式计算--&gt; 渲染树\n  渲染树 --添加--&gt; 伪元素渲染对象\n</code></pre>\n<h4>关键优化策略</h4>\n<ol>\n<li><strong>增量样式计算</strong>：仅更新受影响的&quot;脏&quot;节点</li>\n<li><strong>样式共享</strong>：相同样式规则复用计算结果</li>\n<li><strong>惰性计算</strong>：延迟访问时才计算布局属性</li>\n</ol>\n",
            "url": "https://clark-cui.top/posts/浏览器渲染原理（一）.html",
            "title": "浏览器渲染原理（一）",
            "date_modified": "2025-06-29T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>什么是协商缓存和强缓存？两者有什么区别？</h2>\n<h3>关于 HTTP 缓存</h3>\n<p>HTTP 缓存是基于 HTTP 协议的一种机制，通过<strong>存储和重用之前请求的资源副本</strong>（如 HTML、CSS、JavaScript、图片等），减少客户端与服务器之间的重复数据传输，从而<strong>提高网页加载速度、降低服务器负载、节省带宽</strong>。其核心目的是通过重用已有的响应数据，避免每次都从源服务器获取资源。</p>\n<p><a href=\"https://httpwg.org/specs/rfc9111.html\">HTTP 缓存标准</a>把缓存分为两类：</p>\n<ul>\n<li><strong>私有缓存</strong>： 私有缓存是绑定到特定客户端的缓存，通常指浏览器缓存。它存储的响应仅对当前用户可见，不与其他用户共享。适用场景：存储用户的个性化内容（如登录后的页面、用户特定数据）。</li>\n<li><strong>共享缓存</strong>：共享缓存位于客户端和服务器之间，存储的响应可被多个用户共享，用于减少服务器负载和网络流量。典型实现：代理服务器（如 Squid、Nginx 反向代理）、CDN 节点、ISP 缓存等。</li>\n</ul>\n<p><strong>关键性区别总结</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特性</th>\n<th>私有缓存</th>\n<th>共享缓存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">存储位置</td>\n<td>客户端</td>\n<td>中间层(代理服务器、CDN、反向代理服务器)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">共享性</td>\n<td>私有</td>\n<td>共享</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">适用场景</td>\n<td>个性化、登录后的页面、用户特定数据</td>\n<td>公共资源、静态资源(图片、css)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">控制指令</td>\n<td>Cache-Control: private</td>\n<td>Cache-Control: public</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">安全性</td>\n<td>仅对当前用户可见，安全</td>\n<td>可被多个用户共享，不安全</td>\n</tr>\n</tbody>\n</table>\n<h3>HTTP 缓存控制指令</h3>\n<p>HTTP 缓存主要通过<strong>请求头和响应头中的字段</strong>(如 <code>Cache-Control</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>ETag</code> 等) 控制缓存策略，分为以下两种工作方式：</p>\n<ol>\n<li><strong>强缓存</strong>： 强缓存是指浏览器在第一次请求资源并得到响应后，将响应存储在客户端缓存中，后续再请求相同的资源时，<strong>浏览器会直接从缓存中获取响应，而不会向服务器发起请求</strong>。 由 <code>Cache-Control</code>（HTTP 1.1） 或 <code>Expires</code>（HTTP 1.0） 指令控制，如 <code>Cache-Control: max-age=3600</code>，表示缓存 1 小时。</li>\n<li><strong>协商缓存</strong>：协商缓存是指客户端在请求资源时，会携带一些请求头信息，如 <code>Last-Modified/If-Modified-Since</code>（使用资源最后修改时间判断）、<code>ETag/If-None-Match</code>（使用资源唯一标识符判断） 等， <strong>服务器根据这些请求头信息判断客户端是否需要更新资源</strong>，如果客户端不需要更新，则返回 304 Not Modified，否则返回 200 OK。</li>\n</ol>\n<blockquote>\n<p>关于协商缓存的具体实现，可以参考 express 的源码中关于缓存的实现逻辑。 <a href=\"https://github.com/expressjs/express/blob/master/lib/request.js#L457\">链接地址</a></p>\n</blockquote>\n<h3>缓存破坏（解决前端部署后的缓存问题）</h3>\n<p>在现代 Web 开发中，JavaScript 和 CSS 资源会随着开发的进展而频繁更新。但<strong>由于其静态资源文件名未改变，浏览器会优先从缓存中获取，从而导致页面加载时出现旧版本的资源</strong>。为了解决这个问题，我们可以通过一些方法来破坏缓存：</p>\n<ol>\n<li><strong>使用基于版本号或哈希值的文件名</strong>： 在构建时，使用基于版本号或哈希值的文件名，如 <code>main.js?v=1.0.0</code>，这样每次部署后文件名都会改变，从而破坏缓存。（一些成熟的构建工具如 Webpack、Vite 等，都提供了内置的版本号或哈希值生成功能）</li>\n<li><strong>对于主资源禁用缓存</strong>： 与子资源不同，主资源的 URL 不能像子资源 URL 一样被修饰，这时我们可以在 html 的 head 标签中添加以下内容，防止其被浏览器缓存。</li>\n</ol>\n<pre><code class=\"language-html\">&lt;meta\n\thttp-equiv=&quot;Cache-Control&quot;\n\tcontent=&quot;no-cache, no-store, must-revalidate&quot;\n/&gt;\n&lt;meta\n\thttp-equiv=&quot;Pragma&quot;\n\tcontent=&quot;no-cache&quot;\n/&gt;\n&lt;meta\n\thttp-equiv=&quot;Expires&quot;\n\tcontent=&quot;0&quot;\n/&gt;\n</code></pre>\n<blockquote>\n<p>注意： 现代浏览器可能忽略 Meta 标签，因此必须结合 HTTP 头使用。</p>\n</blockquote>\n<pre><code class=\"language-Nginx\">location / {\n    add_header Cache-Control &quot;no-store, no-cache, must-revalidate&quot;;\n    add_header Pragma &quot;no-cache&quot;;\n    expires 0;\n}\n</code></pre>\n",
            "url": "https://clark-cui.top/posts/前端面试题整理：杂篇（一）.html",
            "title": "前端面试题整理：杂篇（一）",
            "date_modified": "2025-03-20T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>关于表单元素 input 上的 v-model 绑定</h2>\n<p>一直以来我都有个错觉，认为在 input 等输入类型的表单元素上，v-model 指令绑定的是 <code>value</code> 属性和 <code>change</code> 事件，直到后来自己封装某个自定义指令的时候（需要手动触发一下双向绑定），使用 dispatch 分发 <code>change</code> 事件并没有触发绑定值的更新，遂去翻看文档，发现了以下内容。</p>\n<ImageBuilder :source=\"['错觉_v-model.jpg']\" size=\"large\" />\n<p>看来有些事情还是不能想当然，多看文档总是对的。。。</p>\n<blockquote>\n<p>总结： 官方文档中，input 元素上的 v-model 绑定的是 <code>value</code> 属性和 <code>input</code> 事件。</p>\n</blockquote>\n<h2>Axios 提交 Date 类型数据时的时区自动变更问题</h2>\n<h3>问题描述</h3>\n<p>在使用 <code>Axios</code> 提交 Date 类型的数据时，发现请求体中的时间总是与代码中的时间不一致，这使我非常困惑。这个问题是在某次改项目中的 bug 时发现的，排查了很久。</p>\n<h3>根本原因</h3>\n<p><code>Axios</code> 对于提交的 Date 类型的数据，会将其序列化为时间字符串。<br>\n这里涉及到 <code>JavaScript</code> 语言在序列化 Date 对象时的默认行为：</p>\n<p><strong><code>JavaScript</code> 语言在序列化 Date 对象时（如通过 <code>JSON.stringify</code>），会调用 <code>Date.prototype.toISOString()</code> 方法，将日期转换为 ISO 8601 格式（如 2025-05-04T01:00:00.000Z）</strong>。其中的 Z 表示 UTC 时间（0 时区），而本地时间（如东八区）会被自动转换为 UTC 时间（减去 8 小时）。如图：</p>\n<ImageBuilder :source=\"['Snipaste_Date序列化的问题.png']\" size=\"large\" />\n<blockquote>\n<p>为什么要这样做？JavaScript 语言这样做的合理性： Date 对象的 ISO 序列化是为了标准化时间表示，便于跨系统传输。UTC 时间是国际通用标准，因此 JavaScript 的行为是合理的。</p>\n</blockquote>\n<h3>解决方案</h3>\n<ol>\n<li><strong>不要直接提交 Date 类型的数据</strong>，而是将 Date 对象转换为本地时间字符串，然后再提交。</li>\n<li>后端进行时区处理</li>\n</ol>\n<h2>关于使用 CSS order 属性在不改变 dom 结构的情况下改变元素的显示顺序</h2>\n<p>是这样的，最近我在维护一个项目的时候遇到这样一个需求，<code>页面上有一个元素，它的内部有两个子元素，它们的dom结构从上到下是 A -&gt; B，现在我希望让 B 显示在父盒子的左侧， A 显示在右侧，并且 A 的宽度是父盒子的宽度减去B的宽度（也就是 A 要自适应剩余的宽度）</code>。</p>\n<p>这种情况下使用 flex 布局 + order 属性 正好可以解决这个问题。</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset=&quot;UTF-8&quot; /&gt;\n\t\t&lt;meta\n\t\t\tname=&quot;viewport&quot;\n\t\t\tcontent=&quot;width=device-width, initial-scale=1.0&quot;\n\t\t/&gt;\n\t\t&lt;title&gt;Document&lt;/title&gt;\n\t\t&lt;style&gt;\n\t\t\t.container {\n\t\t\t\tdisplay: flex;\n\t\t\t\twidth: 300px;\n\t\t\t\tcolor: #fff;\n\t\t\t}\n\t\t\t.item1 {\n\t\t\t\torder: 2;\n\t\t\t\tflex: 1;\n\t\t\t\tbackground-color: blue;\n\t\t\t}\n\t\t\t.item2 {\n\t\t\t\torder: 1;\n\t\t\t\twidth: 50px;\n\t\t\t\tbackground-color: red;\n\t\t\t}\n\t\t&lt;/style&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t&lt;div class=&quot;container&quot;&gt;\n\t\t\t&lt;div class=&quot;item1&quot;&gt;item1&lt;/div&gt;\n\t\t\t&lt;div class=&quot;item2&quot;&gt;item2&lt;/div&gt;\n\t\t&lt;/div&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ImageBuilder :source=\"['order属性.png']\" size=\"large\"/>\n<p>🔗<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/order\">查看 mdn 关于 order 属性的描述</a></p>\n",
            "url": "https://clark-cui.top/posts/前端开发常见错觉.html",
            "title": "前端工作中的经验与教训",
            "date_modified": "2025-03-18T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>Vue-Router 的两种路由模式？</h2>\n<p>Vue-Router 支持两种路由模式：hash 和 history。</p>\n<ul>\n<li><strong>hash 模式</strong>：使用 URL 的 hash 来存储路由信息，即 URL 中会包含一个 # 符号，如：<a href=\"http://www.example.com/#/about%E3%80%82\">http://www.example.com/#/about。</a></li>\n<li><strong>history 模式</strong>：使用 HTML5 的 history API 来存储路由信息，即 URL 中不会包含 # 符号，如：<a href=\"http://www.example.com/about%E3%80%82\">http://www.example.com/about。</a></li>\n</ul>\n<p>它们的区别如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对比项</th>\n<th style=\"text-align:center\">Hash 模式</th>\n<th style=\"text-align:center\">History 模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">URL 美观度</td>\n<td style=\"text-align:center\">差</td>\n<td style=\"text-align:center\">好</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">需要服务器支持</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">兼容性</td>\n<td style=\"text-align:center\">几乎所有浏览器</td>\n<td style=\"text-align:center\">需要支持 HTML5 的 history API</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SEO 优化</td>\n<td style=\"text-align:center\">差(部分爬虫忽略哈希)</td>\n<td style=\"text-align:center\">较好</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">部署成本</td>\n<td style=\"text-align:center\">低</td>\n<td style=\"text-align:center\">高(需要服务器配合)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>history 模式官方配置说明 <a href=\"https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B\">服务器配置示例</a></p>\n</blockquote>\n<h2>Vue-Router 有哪些钩子函数？它们的执行顺序？</h2>\n<h3>钩子函数类型</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">​ 类型 ​</th>\n<th style=\"text-align:left\">​ 钩子函数</th>\n<th style=\"text-align:left\">​ ​ 触发时机 ​</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">全局守卫</td>\n<td style=\"text-align:left\">beforeEach</td>\n<td style=\"text-align:left\">全局前置守卫，每次导航前触发</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">beforeResolve</td>\n<td style=\"text-align:left\">全局解析守卫，导航被确认前触发（适合处理异步数据）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">afterEach</td>\n<td style=\"text-align:left\">全局后置钩子，导航完成后触发（无 next 参数）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">路由独享守卫</td>\n<td style=\"text-align:left\">beforeEnter</td>\n<td style=\"text-align:left\">在单个路由配置中定义，进入该路由前触发</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">组件内守卫</td>\n<td style=\"text-align:left\">beforeRouteEnter</td>\n<td style=\"text-align:left\">进入组件前触发（无法访问实例）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">beforeRouteUpdate</td>\n<td style=\"text-align:left\">当前路由改变但组件复用时触发（如 /user/:id 参数变化）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">beforeRouteLeave</td>\n<td style=\"text-align:left\">离开组件前触发（常用于阻止用户未保存离开）</td>\n</tr>\n</tbody>\n</table>\n<h3>钩子函数执行顺序</h3>\n<ol>\n<li>导航被触发。</li>\n<li><strong>在失活的组件里调用 beforeRouteLeave 守卫</strong>。</li>\n<li><strong>调用全局的 beforeEach 守卫</strong>。</li>\n<li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li>\n<li><strong>在路由配置里调用 beforeEnter</strong>。</li>\n<li>解析异步路由组件。</li>\n<li><strong>在被激活的组件里调用 beforeRouteEnter</strong>。</li>\n<li><strong>调用全局的 beforeResolve 守卫(2.5+)</strong>。</li>\n<li>导航被确认。</li>\n<li><strong>调用全局的 afterEach 钩子</strong>。</li>\n<li>触发 DOM 更新。</li>\n<li><strong>调用 beforeRouteEnter 守卫中传给 next 的回调函数</strong>，创建好的组件实例会作为回调函数的参数传入</li>\n</ol>\n<h2>Vue-Router 如何实现路由懒加载？</h2>\n<p>Vue-Router 默认支持路由懒加载，即在需要时才加载路由组件，从而提高性能。<br>\n在 Vue-Router 中，路由的懒加载是通过<strong>动态导入</strong>组件来实现的。</p>\n<pre><code class=\"language-javascript\">const Home = () =&gt; import('./views/Home.vue') // 动态导入组件\nconst About = () =&gt; import('./views/About.vue') // 动态导入组件\nconst routes = [\n\t{ path: '/home', component: Home },\n\t{ path: '/about', component: About }\n]\nconst router = createRouter({})\nrouter.addRoute(routes)\nexport default router\n</code></pre>\n<p>在上面的代码中，<code>Home</code> 和 <code>About</code> 组件都是通过动态导入的方式定义的，即使用 <code>() =&gt; import('./views/Home.vue')</code> 的形式。<br>\n这样，当用户访问 <code>/home</code> 或 <code>/about</code> 路径时，相应的组件才会被加载，从而实现了路由懒加载。</p>\n<blockquote>\n<p>需要注意的是，路由的动态导入（即路由懒加载）​ <strong>必须依赖打包工具的支持</strong>才能实现真正的代码分割和按需加载。</p>\n</blockquote>\n",
            "url": "https://clark-cui.top/posts/前端面试题整理：Vue篇（二）.html",
            "title": "前端面试题整理：Vue篇（二）",
            "date_modified": "2024-10-18T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>对 Vue 框架的理解</h2>\n<h3>Vue 是什么?</h3>\n<p>Vue 是一个<strong>响应式</strong>的、<strong>数据驱动</strong>的 JavaScript 框架。</p>\n<h3>Vue 为什么出现？Vue 的出现解决了什么问题？</h3>\n<p>在 Vue 这种响应式的框架出现之前，前端大致经历了几个发展阶段：</p>\n<ol>\n<li>完全静态页面时期，前端展示的内容通常只是一个静态的页面，没有什么动态特性</li>\n<li>早期的服务端渲染时期，以 jsp、asp、php 这种在服务端组织 HTML 代码为主的形式，前后端通常不分离，前端的工作包含在后端之中</li>\n<li>JQuery + Ajax 时期，Ajax 的出现，也促使了前后端的分离，这时候前端可以通过 Ajax 的形式动态的从服务器获取内容，然后使用 JQuery 之类的库将获取到的数据通过 Dom 操作的形式更新到页面上</li>\n<li>现代 JavaScript 框架时期，Angular、React、Vue 等响应式框架出现，前端可以从 Dom 操作中分离，只关心数据和视图，响应式框架负责 Dom Diff（或脏检查）和更新</li>\n</ol>\n<p>Vue 等响应式框架的出现，<strong>解决的是原来前端需要频繁的通过 JQuery 或者原生 api 操作 Dom 来更新界面的问题</strong>，Vue 等响应式框架出现后，前端可以<strong>从 Dom 操作中分离出来，只需要关注数据和视图</strong>就可以了。</p>\n<h3>Vue 如何实现的响应式和数据驱动？</h3>\n<p>Vue 的响应式是通过<strong>数据劫持</strong>的相关 api 来实现的，2.0 是<code>Object.defineProperty</code>,3.0 是<code>Proxy</code>，数据驱动是通过<strong>观察者模式</strong>模式来实现的。</p>\n<h2>对 Vue 中双向绑定的理解</h2>\n<h3>什么是双向绑定？</h3>\n<p>双向绑定指的是，当数据模型发生改变时，对应的视图也会自动发生改变，反过来，当视图有变化时，数据模型也会随之改变。</p>\n<h3>双向绑定的实现？</h3>\n<p>主要是通过<strong>数据劫持</strong>和<strong>事件监听</strong></p>\n<p>通过拦截数据模型的访问和修改，实现数据的自动同步。通过监听视图中的用户输入事件（如 input、change 等），实现视图到数据模型的同步。</p>\n<h2>对 SPA（单页面应用）的理解</h2>\n<h3>什么是 SPA？</h3>\n<p>SPA（Single Page Application，单页应用）是一种 Web 应用程序的设计模式，它通过动态加载内容来实现页面的无刷新更新。SPA 的核心思想是在用户与应用程序交互时，只加载和更新必要的部分内容，而不是整个页面。这种设计模式可以提供更流畅的用户体验，减少页面加载时间，并提高应用程序的响应速度。</p>\n<h3>SPA 的特点？</h3>\n<ol>\n<li>\n<p><strong>无刷新页面更新</strong>：SPA 通过动态加载内容来实现页面的无刷新更新，用户在浏览应用程序时不会看到页面重新加载的过程。</p>\n</li>\n<li>\n<p><strong>前端路由</strong>：SPA 通常使用前端路由（Front-End Routing）来管理页面导航。前端路由通过 JavaScript 来处理 URL 的变化，并根据 URL 加载相应的页面内容。</p>\n</li>\n<li>\n<p><strong>前后端分离</strong>：SPA 通常采用前后端分离的架构，前端负责页面渲染和用户交互，后端负责提供数据和服务。</p>\n</li>\n<li>\n<p><strong>动态内容加载</strong>：SPA 通过 AJAX、Fetch API 等技术动态加载内容，而不是通过传统的页面刷新来加载内容。</p>\n</li>\n</ol>\n<h3>SPA 的实现？</h3>\n<p>SPA 的实现<br>\nSPA 的实现通常依赖于以下几个核心技术：</p>\n<ul>\n<li>\n<p><strong>前端框架</strong>：如 React、Vue.js、Angular 等，这些框架提供了组件化开发、状态管理和前端路由等功能，帮助开发者构建复杂的 SPA。</p>\n</li>\n<li>\n<p><strong>前端路由</strong>：如 React Router、Vue Router、Angular Router 等，这些库提供了前端路由功能，帮助开发者管理页面导航和 URL 变化。</p>\n</li>\n<li>\n<p><strong>AJAX/Fetch API</strong>：用于动态加载数据，实现页面的无刷新更新。</p>\n</li>\n<li>\n<p><strong>状态管理</strong>：如 Redux、Vuex、MobX 等，用于管理应用程序的状态，确保状态的一致性和可预测性。</p>\n</li>\n</ul>\n<h2>为什么 Vue 中的 data 属性是一个函数而不是一个对象？</h2>\n<p>为了实现组件的<strong>数据隔离</strong>。</p>\n<p>当一个组件被多次使用时，如果 data 属性是一个对象，那么多个组件实例将共享同一个 data 对象，这可能导致数据的混乱和不可预测性。</p>\n<p>而如果 data 属性是一个函数，每个组件实例都会调用该函数来返回一个新的 data 对象，这样每个组件实例都会有自己独立的数据副本，避免了数据共享的问题。</p>\n<h2>Vue 组件之间传值有几种方式？</h2>\n<h3>1. 父子组件之间传值</h3>\n<h4>父传子 - props</h4>\n<pre><code class=\"language-html\">&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n\t&lt;ChildComponent :message=&quot;parentMessage&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\timport ChildComponent from './ChildComponent.vue'\n\texport default {\n\t\tcomponents: {\n\t\t\tChildComponent\n\t\t},\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tparentMessage: 'Hello from Parent!'\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- 子组件 --&gt;\n&lt;template&gt;\n\t&lt;div&gt;{{ message }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tprops: {\n\t\t\tmessage: {\n\t\t\t\ttype: String\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n</code></pre>\n<h4>子传父 - $emit</h4>\n<pre><code class=\"language-html\">&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n\t&lt;ChildComponent @child-event=&quot;handleEvent&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\timport ChildComponent from './ChildComponent.vue'\n\texport default {\n\t\tcomponents: {\n\t\t\tChildComponent\n\t\t},\n\t\tmethods: {\n\t\t\thandleEvent(data) {\n\t\t\t\tconsole.log(data) // 接收到的数据\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- 子组件 --&gt;\n&lt;template&gt;\n\t&lt;button @click=&quot;sendData&quot;&gt;Send Data&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tmethods: {\n\t\t\tsendData() {\n\t\t\t\tthis.$emit('child-event', 'Hello from Child!')\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n</code></pre>\n<h3>2. 兄弟组件之间传值</h3>\n<h4>通过父组件作为中介（使用父组件的状态和方法）</h4>\n<pre><code class=\"language-html\">&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n\t&lt;SiblingA @updateParentState=&quot;updateState&quot; /&gt;\n\t&lt;SiblingB :state=&quot;parentState&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\timport SiblingA from './SiblingA.vue'\n\timport SiblingB from './SiblingB.vue'\n\n\texport default {\n\t\tcomponents: {\n\t\t\tSiblingA,\n\t\t\tSiblingB\n\t\t},\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tparentState: ''\n\t\t\t}\n\t\t},\n\t\tmethods: {\n\t\t\tupdateState(newState) {\n\t\t\t\tthis.parentState = newState\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- SiblingA --&gt;\n&lt;template&gt;\n\t&lt;button @click=&quot;updateState&quot;&gt;Update State&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tmethods: {\n\t\t\tupdateState() {\n\t\t\t\tthis.$emit('updateParentState', 'New State')\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- SiblingB --&gt;\n&lt;template&gt;\n\t&lt;div&gt;{{ state }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tprops: {\n\t\t\tstate: String\n\t\t}\n\t}\n&lt;/script&gt;\n</code></pre>\n<h3>3. 全局事件总线</h3>\n<h4>创建一个全局的 Vue 实例作为事件中心，用于非父子关系的组件间通信。</h4>\n<pre><code class=\"language-js\">// eventBus.js\nimport Vue from 'vue';\nexport const EventBus = new Vue();\n\n// 组件 A\nimport { EventBus } from './eventBus';\n\nexport default {\n  methods: {\n    sendData() {\n      EventBus.$emit('global-event', 'Hello from Component A!');\n    }\n  }\n};\n\n// 组件 B\nimport { EventBus } from './eventBus';\n\nexport default {\n  created() {\n    EventBus.$on('global-event', this.handleEvent);\n  },\n  beforeDestroy() {\n    EventBus.$off('global-event', this.handleEvent);\n  },\n  methods: {\n    handleEvent(data) {\n      console.log(data); // 接收到的数据\n    }\n  }\n};\n</code></pre>\n<h3>4. 全局状态管理（Vuex）</h3>\n<pre><code class=\"language-js\">// store.js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n\tstate: {\n\t\tcount: 0\n\t},\n\tmutations: {\n\t\tincrement(state) {\n\t\t\tstate.count++\n\t\t}\n\t},\n\tactions: {\n\t\tincrement({ commit }) {\n\t\t\tcommit('increment')\n\t\t}\n\t},\n\tgetters: {\n\t\tgetCount: state =&gt; state.count\n\t}\n})\n\n// main.js\nimport Vue from 'vue'\nimport App from './App.vue'\nimport store from './store'\n\nnew Vue({\n\tstore,\n\trender: h =&gt; h(App)\n}).$mount('#app')\n</code></pre>\n<pre><code class=\"language-html\">// 组件中使用\n&lt;template&gt;\n\t&lt;div&gt;{{ $store.getters.getCount }}&lt;/div&gt;\n\t&lt;button @click=&quot;$store.dispatch('increment')&quot;&gt;Increment&lt;/button&gt;\n&lt;/template&gt;\n</code></pre>\n<h3>5. ref 引用</h3>\n<h4>父组件可以通过 ref 属性引用子组件，并通过 $refs 访问子组件实例。</h4>\n<pre><code class=\"language-html\">&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n\t&lt;ChildComponent ref=&quot;child&quot; /&gt;\n\t&lt;button @click=&quot;callChildMethod&quot;&gt;Call Child Method&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\timport ChildComponent from './ChildComponent.vue'\n\texport default {\n\t\tcomponents: {\n\t\t\tChildComponent\n\t\t},\n\t\tmethods: {\n\t\t\tcallChildMethod() {\n\t\t\t\tthis.$refs.child.childMethod()\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- 子组件 --&gt;\n&lt;script&gt;\n\texport default {\n\t\tmethods: {\n\t\t\tchildMethod() {\n\t\t\t\tconsole.log('Called child method')\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n</code></pre>\n<h3>6. Provide/Inject</h3>\n<h4>上层组件通过 provide 选项提供数据，下层组件通过 inject 选项注入数据。</h4>\n<pre><code class=\"language-html\">&lt;!-- 上层组件 --&gt;\n&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;ChildComponent /&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tprovide() {\n\t\t\treturn {\n\t\t\t\tparentData: 'Hello from Parent!'\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- 下层组件 --&gt;\n&lt;template&gt;\n\t&lt;div&gt;{{ parentData }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tinject: ['parentData']\n\t}\n&lt;/script&gt;\n</code></pre>\n<h2>Vue 组件生命周期</h2>\n<p>Vue 组件的生命周期包括以下几个阶段：</p>\n<ol>\n<li><strong>beforeCreate</strong>：组件实例被创建之前调用。</li>\n<li><strong>created</strong>：组件实例被创建之后调用。</li>\n<li><strong>beforeMount</strong>：组件挂载之前调用。</li>\n<li><strong>mounted</strong>：组件挂载之后调用。</li>\n<li><strong>beforeUpdate</strong>：组件更新之前调用。</li>\n<li><strong>updated</strong>：组件更新之后调用。</li>\n<li><strong>beforeDestroy</strong>：组件销毁之前调用。</li>\n<li><strong>destroyed</strong>：组件销毁之后调用。</li>\n</ol>\n<p>父子组件触发生命周期的顺序：</p>\n<pre><code class=\"language-markdown\">挂载阶段:\n父: beforeCreate → created → beforeMount\n子: beforeCreate → created → beforeMount → mounted\n父: mounted\n\n更新阶段:\n父: beforeUpdate\n子: beforeUpdate → updated\n父: updated\n\n销毁阶段:\n父: beforeDestroy\n子: beforeDestroy → destroyed\n父: destroyed\n</code></pre>\n<p><strong>父组件总是在子组件的 mouted、updated、destroyed 生命周期函数调用之后再调用自身对应的生命周期函数，如果子组件的生命周期函数中存在异步操作，也不会等待其执行完毕，而是会立即继续执行，即：</strong></p>\n<ol>\n<li>父 mounted → 在 所有子组件 mounted 之后</li>\n<li>父 updated → 在 所有子组件 updated 之后</li>\n<li>父 destroyed → 在 所有子组件 destroyed 之后</li>\n</ol>\n<ImageBuilder :source=\"['lifecycle.jpg']\" />\n<h2>v-if 和 v-show 的区别</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特性</th>\n<th style=\"text-align:center\">v-if</th>\n<th style=\"text-align:center\">v-show</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>原理</strong></td>\n<td style=\"text-align:center\">真实的添加/删除 DOM 元素</td>\n<td style=\"text-align:center\">控制 CSS 样式 display</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>编译过程</strong></td>\n<td style=\"text-align:center\">编译时有条件分支</td>\n<td style=\"text-align:center\">编译时无条件分支</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>初始渲染</strong></td>\n<td style=\"text-align:center\">惰性的，如果初始条件为假，则什么也不做</td>\n<td style=\"text-align:center\">不管初始条件如何，始终都会渲染</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>切换开销</strong></td>\n<td style=\"text-align:center\">有较高的切换开销，切换过程中会销毁和重建元素</td>\n<td style=\"text-align:center\">无切换开销，只是简单的基于 CSS 切换</td>\n</tr>\n</tbody>\n</table>\n<h2>v-for 和 v-if 为什么不推荐放在一起</h2>\n<p>同时使用 v-for 和 v-if 会导致优先级不明显，在 vue2 中 v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中，造成性能浪费。</p>\n<h2>watch 和 computed 的区别</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特性</th>\n<th style=\"text-align:center\">computed</th>\n<th style=\"text-align:center\">watch</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>目的</strong></td>\n<td style=\"text-align:center\">基于其他数据生成新的值</td>\n<td style=\"text-align:center\">监听数据的变化，并执行相应的操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>返回值</strong></td>\n<td style=\"text-align:center\">必须</td>\n<td style=\"text-align:center\">不需要</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>缓存</strong></td>\n<td style=\"text-align:center\">有缓存</td>\n<td style=\"text-align:center\">无缓存</td>\n</tr>\n</tbody>\n</table>\n<h2>nextTick 是什么，它的作用？</h2>\n<p><code>nextTick</code> 是 Vue 提供的异步方法，用于 <strong>​ 在下次 DOM 更新循环结束之后执行回调</strong>。它解决了数据变化后 ​ 立即操作 DOM 可能获取旧状态 ​ 的问题。</p>\n<h3>为什么需要使用 nextTick？</h3>\n<p>由于 Vue 的异步更新机制，<strong>Vue 在检测到数据变化时，不会立即更新 DOM</strong>，而是开启一个队列，缓冲同一事件循环中的所有数据变更。</p>\n<h2>Vue2 和 Vue3 的区别</h2>\n<h3>响应式系统变更</h3>\n<p>核心 API 由<code>Object.defineProperty</code>改为<code>Proxy</code>，带来了以下地方的优化：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特性</th>\n<th style=\"text-align:left\">Vue2</th>\n<th style=\"text-align:left\">Vue3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">数组响应式方法</td>\n<td style=\"text-align:left\">仅支持 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code></td>\n<td style=\"text-align:left\">支持所有数组方法</td>\n</tr>\n</tbody>\n</table>\n",
            "url": "https://clark-cui.top/posts/前端面试题整理：Vue篇（一）.html",
            "title": "前端面试题整理：Vue篇（一）",
            "date_modified": "2024-10-17T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>项目一：天气 app</h2>\n<ImageBuilder :source=\"['Snipaste_demo_weather.jpg']\" :size=\"'small'\"/>\n<p>项目地址：<a href=\"https://github.com/jianhua1996/flutter-weather\">https://github.com/jianhua1996/flutter-weather</a></p>\n<h2>项目二：音乐播放器</h2>\n<ImageBuilder :source=\"['Snipaste_demo_music_player.jpg', 'Snipaste_demo_music_player2.jpg', 'Snipaste_demo_music_player3.png', 'Snipaste_demo_music_player5.jpg']\" :size=\"'small'\"/>\n<p>项目地址：<a href=\"https://github.com/jianhua1996/flutter-music-player\">https://github.com/jianhua1996/flutter-music-player</a></p>\n",
            "url": "https://clark-cui.top/posts/Flutter小项目展示.html",
            "title": "Flutter小项目展示",
            "date_modified": "2024-10-09T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>1. Card 组件</h2>\n<p>Card 组件是 Flutter 中最常用的组件之一，它可以用来显示一些内容，<strong>它的默认样式是一个略微圆角且带有阴影凸起的面板</strong>，Card 组件可以包含一个子组件，也可以没有子组件。Card 组件的主要属性有：</p>\n<ul>\n<li>color：Card 组件的背景颜色。</li>\n<li>elevation：Card 组件的阴影大小。</li>\n<li>shape：Card 组件的形状。</li>\n<li>clipBehavior：Card 组件的裁剪行为。</li>\n<li>child：Card 组件的子组件。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/material/Card-class.html\">查看更多属性</a></p>\n<p>Card 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">Card(\n  color: Colors.blue,\n  elevation: 10,\n  child: Padding(\n    padding: const EdgeInsets.all(8.0),\n    child: Text(\n      'This is a card',\n      style: TextStyle(color: Colors.white),\n    ),\n  ),\n),\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_card.png']\" />\n<h2>2. ListTile 组件</h2>\n<p>ListTile 组件是 Flutter 中用来显示列表项的组件，通常与 Listview 组件、Card 组件等一起搭配使用，它可以<strong>用来展示一个标题、一段描述、一张图片或者一个小部件</strong>，ListTile 组件的主要属性有：</p>\n<ul>\n<li>leading：ListTile 组件的左侧组件，通常是一个小部件。</li>\n<li>title：ListTile 组件的标题。</li>\n<li>subtitle：ListTile 组件的副标题。</li>\n<li>trailing：ListTile 组件的右侧组件，通常是一个小部件。</li>\n<li>dense：ListTile 组件是否显示为紧凑模式。</li>\n<li>enabled：ListTile 组件是否可以点击。</li>\n<li>onTap：ListTile 组件的点击事件。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/material/ListTile-class.html\">查看更多属性</a></p>\n<p>ListTile 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">ListTile(\n  leading: Icon(Icons.person),\n  title: Text('标题'),\n  subtitle: Text('子标题'),\n  trailing: Icon(Icons.arrow_forward),\n  dense: true,\n  enabled: true,\n  onTap: () {\n    print('ListTile 被点击了');\n  },\n)\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_listtile.png']\" />\n<h2>3. CircleAvatar 组件</h2>\n<p>CircleAvatar 组件是一个圆形的头像组件，它可以<strong>用来显示用户头像或者其他圆形的图片</strong>，CircleAvatar 组件的主要属性有：</p>\n<ul>\n<li>backgroundImage：CircleAvatar 组件的背景图片。</li>\n<li>backgroundColor：CircleAvatar 组件的背景颜色。</li>\n<li>foregroundColor：CircleAvatar 组件的前景颜色。</li>\n<li>radius：CircleAvatar 组件的圆角半径。</li>\n<li>child：CircleAvatar 组件的子组件。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/material/CircleAvatar-class.html\">查看更多属性</a></p>\n<p>CircleAvatar 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">CircleAvatar(\n  backgroundImage:\n      const NetworkImage('https://www.example.com/example.jpg'),\n  backgroundColor: Colors.lightGreen.shade100,\n  radius: 50,\n  child: const FlutterLogo(\n    size: 50,\n  ),\n),\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_circleavatar.jpg']\" />\n<h2>4. Divider 组件</h2>\n<p>Divider 组件是一个分割线组件，它可以<strong>用来分隔不同列表项或者不同区域</strong>，Divider 组件的主要属性有：</p>\n<ul>\n<li>height：Divider 组件的高度。</li>\n<li>thickness：Divider 组件的粗细。</li>\n<li>indent：Divider 组件距离左侧距离。</li>\n<li>endIndent：Divider 组件距离右侧距离。</li>\n<li>color：Divider 组件的颜色。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/material/Divider-class.html\">查看更多属性</a></p>\n<p>Divider 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">Column(\n  children: [\n    CircleAvatar(\n      backgroundImage:\n          const NetworkImage('https://www.example.com/example.jpg'),\n      backgroundColor: Colors.lightGreen.shade100,\n      radius: 50,\n      child: const FlutterLogo(\n        size: 50,\n      ),\n    ),\n    const Divider(\n      height: 10,\n      thickness: 2,\n      indent: 10,\n      endIndent: 10,\n      color: Colors.pink,\n    ),\n  ],\n)\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_divider.png']\" />\n<h2>5. ElevatedButton 组件</h2>\n<p>ElevatedButton 组件是一个<strong>带有阴影的按钮组件</strong>，它可以<strong>用来触发一些重要的操作，比如提交表单、打开新页面</strong>等，ElevatedButton 组件的主要属性有：</p>\n<ul>\n<li>onPressed：按钮点击事件。</li>\n<li>style：按钮样式。</li>\n<li>child：按钮子组件。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/material/ElevatedButton-class.html\">查看更多属性</a></p>\n<p>ElevatedButton 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">ElevatedButton(\n  onPressed: () {\n    print('按钮被点击了');\n  },\n  style: ElevatedButton.styleFrom(\n    foregroundColor: Colors.white,\n    backgroundColor: Colors.blue,\n    shadowColor: Colors.blue.shade700,\n    elevation: 12,\n  ),\n  child: Text('按钮'),\n),\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_elevatedbutton.png']\" />\n<h2>6. GestureDetector 组件</h2>\n<p>GestureDetector 组件是一个<strong>手势监听器组件</strong>，它可以<strong>用来监听用户的手势操作，比如滑动、点击、长按等</strong>，GestureDetector 组件的主要属性有：</p>\n<ul>\n<li>onTap：手指单击事件。</li>\n<li>onDoubleTap：手指双击事件。</li>\n<li>onLongPress：手指长按事件。</li>\n<li>child：手势监听器子组件。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/widgets/GestureDetector-class.html\">查看更多属性</a></p>\n<p>GestureDetector 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">GestureDetector(\n  onTap: () {\n    print('手指单击了');\n  },\n  onDoubleTap: () {\n    print('手指双击了');\n  },\n  onLongPress: () {\n    print('手指长按了');\n  },\n  child: Container(\n    width: 100,\n    height: 100,\n    color: Colors.blue,\n  ),\n),\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_gesturedetector.jpg']\" />\n",
            "url": "https://clark-cui.top/posts/Flutter组件学习（二）.html",
            "title": "Flutter组件学习（二）",
            "date_modified": "2024-10-06T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>1. Container 组件</h2>\n<p>Container 组件是 Flutter 中的<code>布局组件</code>，可以类比为 web 开发中的 div 标签。</p>\n<p>它属于单一子组件的容器，接受<code>一个</code> child 参数作为子组件， child 类型<strong>可以是任何 widget，包括其他的 Container 组件</strong>。</p>\n<p><strong>容器在没有子元素的情况下会尽量变得尽可能大，除非传入的约束条件是无界的</strong>，在这种情况下，它们会尽量变得尽可能小。</p>\n<pre><code class=\"language-dart\">Container(\n  decoration: BoxDecoration(\n    color: Colors.blue,\n  ),\n)\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_container1.png']\" />\n<p><strong>有子元素的容器会根据其子元素的大小来调整自身大小</strong>。</p>\n<pre><code class=\"language-dart\">Container(\n  decoration: BoxDecoration(\n    color: Colors.blue,\n  ),\n  child: Text('Hello World!'),\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_container2.png']\" />\n<blockquote>\n<p>Tips: 如果你希望所有的元素都在安全区域展示，不被系统状态栏、导航栏等系统元素遮挡，可以使用 SafeArea 组件。</p>\n</blockquote>\n<pre><code class=\"language-dart\">SafeArea(\n  child: Container(\n    decoration: BoxDecoration(\n      color: Colors.blue,\n    ),\n    child: Text('Hello World!'),\n  ),\n)\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_container3.png']\" />\n<p>如果你给 Container 组件设置了 width 和 height，那么它将会按照你指定的尺寸而不是子组件的尺寸来进行布局。</p>\n<pre><code class=\"language-dart\">SafeArea(\n  child: Container(\n    decoration: BoxDecoration(\n      color: Colors.blue,\n    ),\n    width: 100,\n    height: 100,\n    child: Text('Hello World!'),\n  ),\n)\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_container4.png']\" />\n<h3>1.1 关于外边距（magin）和内边距（padding）</h3>\n<p>container 组件可以通过 margin 和 padding 属性来设置外边距和内边距。（flutter 中外边距和内边距的概念等同于 web 开发中的 margin 和 padding）</p>\n<p>生成内外边距的方法：</p>\n<ul>\n<li>EdgeInsets.all 生成四个方向上都相同的内外边距</li>\n<li>EdgeInsets.symmetric 按照水平或垂直方向生成内外边距</li>\n<li>EdgeInsets.fromLTRB 按照左、上、右、下四个方向生成内外边距</li>\n<li>EdgeInsets.only 按照指定方向生成内外边距</li>\n</ul>\n<pre><code class=\"language-dart\">SafeArea(\n  child: Container(\n    // margin: EdgeInsets.all(10),\n    // padding: EdgeInsets.symmetric(horizontal: 20, vertical: 10),\n    margin: const EdgeInsets.fromLTRB(10, 10, 10, 10),\n    padding:\n        const EdgeInsets.only(left: 20, top: 10, right: 20, bottom: 10),\n    decoration: const BoxDecoration(\n      color: Colors.blue,\n    ),\n    width: 100,\n    height: 100,\n    child: const Text('Hello World!'),\n  ),\n),\n\n</code></pre>\n<h2>2. Rows 和 Columns 组件</h2>\n<p>Rows 和 Columns 组件同样是 Flutter 中的<code>布局组件</code>，可以类比为 web 开发中的 flex 布局。</p>\n<p>它们都属于多子组件的容器，接受<code>多个</code> child 参数作为子组件，入口参数为<code>children</code>， children 指定的子组件类型<strong>可以是任何 widget 或 widget 集合，包括其他的 Rows 和 Columns 组件</strong>。</p>\n<pre><code class=\"language-dart\">SafeArea(\n  child: Column(\n    children: [\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.blue,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.yellow,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.green,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n    ],\n  ),\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_rows_columns.jpg']\" />\n<p><strong>Columns 组件总是会在垂直方向上尽可能的占用空间，而 Rows 组件总是在水平方向上尽可能的占用空间。</strong></p>\n<p>如图所示：</p>\n<ImageBuilder :source=\"['Snipaste_phone_rows_columns2.png']\" />\n<blockquote>\n<p>如果你希望更改这个默认行为，可以通过更改 mainAxisSize 属性来控制 Rows 和 Columns 组件在主轴方向上的尺寸分配。</p>\n<pre><code class=\"language-dart\">Column(\n  mainAxisSize: MainAxisSize.min,\n)\n</code></pre>\n</blockquote>\n<p>另外，Columns 组件还可以设置 verticalDirection 属性来控制子组件的排列方向。</p>\n<pre><code class=\"language-dart\">\nSafeArea(\n  child: Column(\n    // mainAxisSize: MainAxisSize.min,\n    verticalDirection: VerticalDirection.up,\n    children: [\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.blue,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.yellow,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.green,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n    ],\n  ),\n)\n\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_rows_columns3.jpg']\" />\n<p>以及，通过 <code>mainAxisAlignment</code> 属性来控制子组件在主轴方向上的对齐方式，有效的值有：</p>\n<ul>\n<li>MainAxisAlignment.start</li>\n<li>MainAxisAlignment.end</li>\n<li>MainAxisAlignment.center</li>\n<li>MainAxisAlignment.spaceBetween</li>\n<li>MainAxisAlignment.spaceAround</li>\n<li>MainAxisAlignment.spaceEvenly 子组件间距均匀分布</li>\n</ul>\n<p>通过 <code>crossAxisAlignment</code> 属性来控制子组件在交叉轴方向上的对齐方式，有效的值有：</p>\n<ul>\n<li>CrossAxisAlignment.start</li>\n<li>CrossAxisAlignment.end</li>\n<li>CrossAxisAlignment.center</li>\n<li>CrossAxisAlignment.stretch 拉伸子组件，占满交叉轴方向的全部空间</li>\n<li>CrossAxisAlignment.baseline</li>\n</ul>\n<p><strong>这些基本上和 web 开发中的 flex 布局的概念是一致的， mainAxisAlignment 和 crossAxisAlignment 也和 justify-content 和 align-items 相对应</strong></p>\n<h2>3. Image 组件与图片导入</h2>\n<p>Image 组件是 Flutter 中的<code>图片组件</code>，用来展示图片。</p>\n<p>它提供多种构造函数，用于指定加载图像的多种方式：</p>\n<ul>\n<li>Image.asset 加载本地资源图片</li>\n<li>Image.network 加载网络图片</li>\n<li>Image.file 加载本地文件图片</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/widgets/Image-class.html\">查看上述方式的详细用法</a></p>\n<p>Image 组件支持的图片格式有： <strong>JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP</strong>。</p>\n<p>在默认的构造函数中，通过<code>image</code>参数传入一个指定的<code>ImageProvider</code>类型的值，就可以加载指定的图片。</p>\n<p><code>ImageProvider</code> 是一个抽象类，用于提供图片资源。常见的 ImageProvider 类型有 <code>AssetImage</code>、<code>NetworkImage</code>、<code>FileImage</code> 等。</p>\n<pre><code class=\"language-dart\"> Image(\n  image: AssetImage('assets/images/xxx.png'),\n  width: 100,\n  height: 100,\n),\n</code></pre>\n<blockquote>\n<p>需要注意的是，在使用<code>AssetImage</code>类型的<code>ImageProvider</code>时，需要先在 pubspec.yaml 文件中配置图片资源路径来导入图片资源。</p>\n<ImageBuilder :source=\"['Snipaste_phone_image.png']\" />\n</blockquote>\n<h2>4. Text 组件与自定义字体</h2>\n<p>Text 组件是 Flutter 中的<code>文本组件</code>，用来展示文本。</p>\n<p>通过指定<code>style</code>参数，可以设置文本的字体大小、颜色、粗细、斜体等样式。<a href=\"https://api.flutter-io.cn/flutter/widgets/Text-class.html\">查看更多样式设置</a></p>\n<pre><code class=\"language-dart\">Text(\n  'Hello World!',\n  style: TextStyle(\n    fontSize: 20,\n    color: Colors.blue,\n    fontWeight: FontWeight.bold,\n    fontStyle: FontStyle.italic,\n  ),\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_text.png']\" />\n<h3>4.1 自定义字体</h3>\n<p>Flutter 支持自定义字体，通过 <code>fontFamily</code> 参数指定字体名称，就可以使用该字体渲染文本。</p>\n<pre><code class=\"language-dart\">const Text(\n  'Hello World!',\n  style: TextStyle(\n    fontSize: 20,\n    color: Colors.blue,\n    fontWeight: FontWeight.bold,\n    fontStyle: FontStyle.italic,\n    fontFamily: 'PlaywriteDEGrund',\n  ),\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_custom_font2.png']\" />\n<blockquote>\n<p>需要注意的是，自定义字体同样需要在 pubspec.yaml 文件中配置和导入。</p>\n<ImageBuilder :source=\"['Snipaste_phone_custom_font.png']\" />\n</blockquote>\n<h2>5. Icon 组件</h2>\n<p>Icon 组件是 Flutter 中的<code>图标组件</code>，用来展示具体的图标类型。</p>\n<p>通常的做法是<strong>通过指定 flutter 中预定义的 material IconData 枚举值来展示具体的图标</strong>。<a href=\"https://api.flutter-io.cn/flutter/material/Icons-class.html\">查看所有图标类型</a></p>\n<pre><code class=\"language-dart\">Icon(\n  Icons.favorite,\n  size: 30,\n  color: Colors.red,\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_icon.png']\" />\n<h2>6. Expanded 组件</h2>\n<p>Expanded 组件同样是 Flutter 中的<code>布局组件</code>，它可以用来扩展其子组件的尺寸。</p>\n<p>使用 <strong>Expanded 组件可以使 Row、Column 或 Flex 布局的子元素沿着主轴扩展以填充可用空间</strong>（例如，对于 Row 是水平扩展，对于 Column 是垂直扩展）。<strong>如果有多个子元素扩展，可用空间将根据弹性因子<code>flex</code>按比例在它们之间进行分配</strong>。</p>\n<blockquote>\n<p>注意： Expanded 组件只能作为 Row、Column 或 Flex 布局的子元素使用。</p>\n</blockquote>\n<p><a href=\"https://api.flutter-io.cn/flutter/widgets/Expanded-class.html\">查看更多 Expanded 组件用法</a></p>\n<pre><code class=\"language-dart\">Row(\n  children: [\n    Expanded(\n      flex: 2, // 比例因子\n      child: Container(\n        decoration: BoxDecoration(\n          color: Colors.blue,\n        ),\n        width: 100, // 这里设置的宽度不会生效\n        height: 100,\n        child: Text('Hello World!'),\n      ),\n    ),\n    Expanded(\n      child: Container(\n        decoration: BoxDecoration(\n          color: Colors.yellow,\n        ),\n        width: 100, // 这里设置的宽度不会生效\n        height: 100,\n        child: Text('Hello World!'),\n      ),\n    ),\n    Expanded(\n      flex: 2, // 比例因子\n      child: Container(\n        decoration: BoxDecoration(\n          color: Colors.green,\n        ),\n        width: 100, // 这里设置的宽度不会生效\n        height: 100,\n        child: Text('Hello World!'),\n      ),\n    ),\n  ],\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_expanded.png']\" />\n<h2>7. Padding 组件</h2>\n<p>Padding 组件也是 Flutter 中的<code>布局组件</code>之一，用来给父组件添加内边距。</p>\n<p>它接受<code>一个</code> padding 参数，该参数是一个<code>EdgeInsetsGeometry</code>类型的值，用来设置四个方向上的内边距。</p>\n<p>具体用法和 Container 组件中的 padding 属性类似。<a href=\"#_1-1-%E5%85%B3%E4%BA%8E%E5%A4%96%E8%BE%B9%E8%B7%9D-magin-%E5%92%8C%E5%86%85%E8%BE%B9%E8%B7%9D-padding\">回到 1.1</a></p>\n<p><a href=\"https://api.flutter-io.cn/flutter/widgets/Padding-class.html\">更多 Padding 组件用法</a></p>\n<pre><code class=\"language-dart\">Padding(\n  padding: const EdgeInsets.all(20),\n  child: Container(\n    decoration: BoxDecoration(\n      color: Colors.blue,\n    ),\n    width: 100,\n    height: 100,\n    child: Text('Hello World!'),\n  ),\n),\n</code></pre>\n",
            "url": "https://clark-cui.top/posts/Flutter组件学习（一）.html",
            "title": "Flutter组件学习（一）",
            "date_modified": "2024-10-04T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>浏览器的进程模型</h2>\n<h3>进程与线程</h3>\n<p>进程是正在运行的<u>程序的实例</u>，每个进程都有自己<u>独立的</u>一块内存空间，有了进程之后，才可以运行程序的代码。一个进程至少有一个线程，叫做主线程，一个进程也可以运行多个线程，多个线程可以共享数据。</p>\n<h3>浏览器是一个多进程多线程的应用程序</h3>\n<p>浏览器是一个极其复杂的应用程序</p>\n<p>为了避免多个功能之间的相互影响，减少崩溃的几率，浏览器在启动的时候会启动多个进程。</p>\n<p><strong>其中，最主要的进程有</strong>：</p>\n<ol>\n<li>\n<p><strong>浏览器进程</strong></p>\n<p>负责界面显示、用户交互、子进程管理等。</p>\n</li>\n<li>\n<p><strong>网络进程</strong></p>\n<p>负责网络通信，各种资源的加载。</p>\n</li>\n<li>\n<p><strong>渲染进程</strong></p>\n<p>每个标签页都是一个新的渲染进程，渲染进程的主线程负责执行 HTML、CSS、JS 代码</p>\n</li>\n</ol>\n<h3>渲染主线程是如何工作的</h3>\n<p>渲染主线程是浏览器中最繁忙的线程，它处理的任务包括：</p>\n<ul>\n<li>\n<p>解析 html</p>\n</li>\n<li>\n<p>解析 css</p>\n</li>\n<li>\n<p>计算样式</p>\n</li>\n<li>\n<p>布局</p>\n</li>\n<li>\n<p>处理图层</p>\n</li>\n<li>\n<p>每秒把页面画 60 次</p>\n</li>\n<li>\n<p>执行全局 js 代码</p>\n</li>\n<li>\n<p>处理事件函数</p>\n</li>\n<li>\n<p>执行计时器的回调</p>\n</li>\n<li>\n<p>......</p>\n</li>\n</ul>\n<p>为了处理这么多任务的调度，主线程想出了一个办法：队列</p>\n<p>当渲染<u>主线程正在执行任务</u>时，由渲染主线程和浏览器<u>其他</u>线程安排的<u>任务</u>会被暂时放<u>到队列中等待执行</u>，当渲染<u>主线程中的任务执行完毕</u>，会<u>从队列中依次取出</u>排队的任务进行<u>执行</u>。</p>\n<ol>\n<li>\n<p>在最开始的时候，渲染主线程会进入一个无线循环</p>\n<pre><code class=\"language-cpp\">for(;;){\n\n}\n</code></pre>\n</li>\n<li>\n<p>每一次循环会检查队列中是否有任务存在，如果有，就取出第一个任务进行执行，执行完后进入下一次循环；如果没有，则进入休眠状态。</p>\n</li>\n<li>\n<p>其他所有的线程（包括其他进程的线程）可以随时向队列添加任务，新添加的任务会被放到队列的末尾。添加任务时，如果主线程是休眠状态，则唤醒</p>\n</li>\n</ol>\n<h3>何为异步？</h3>\n<p>在代码执行的过程中，无法立即处理（需要等待）的任务就是异步任务，比如：</p>\n<ul>\n<li>\n<p>计时器安排的任务 <code>setTimeout</code>、<code>setInterval</code></p>\n</li>\n<li>\n<p>网络通信后执行的任务 <code>XHR</code>、<code>fetch</code></p>\n</li>\n<li>\n<p>用户操作后执行的任务 <code>addEventListner</code></p>\n</li>\n</ul>\n<p>渲染主线程不会等待以上任务的执行，而是继续执行主线程需要执行的代码。当以上任务（由浏览器的其他进程）执行完成时，会把执行后的结果放到队列中进行等待（直到主线程清空后依次从队列中取出）。</p>\n<h3>JS 代码为何会阻塞渲染</h3>\n<p>因为 js 代码和页面渲染都会在渲染主线程中进行执行，而页面的重绘是异步的过程，需要等待主线程的 js 代码执行完毕。</p>\n<h3>队列中的任务有优先级吗？</h3>\n<p>队列中的任务没有优先级，都是先进先出</p>\n<p>但是<u>队列有优先级</u></p>\n<ul>\n<li>\n<p>每个任务都有一个任务类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同队列中取出任务执行</p>\n</li>\n<li>\n<p>浏览器必须准备好一个微队列，<u>微队列中的任务优先于其他所有任务执行</u>（btw:微队列，vip 的 v）</p>\n<p>添加任务到微队列的方式 <code>Promsie</code> 和<code>MutationObserver</code></p>\n<pre><code class=\"language-javascript\">// 立刻把一个函数放到微队列\nPromise.resolve().then(函数)\n</code></pre>\n</li>\n</ul>\n",
            "url": "https://clark-cui.top/posts/事件循环.html",
            "title": "事件循环",
            "date_modified": "2024-03-12T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h1>测试一下呢呢</h1>\n<p>测试测试</p>\n<pre><code class=\"language-javascript\">console.log('test test')\n</code></pre>\n",
            "url": "https://clark-cui.top/posts/作为测试文章.html",
            "title": "测试文章",
            "summary": "测试测试",
            "date_modified": "2024-02-15T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        }
    ]
}