{
    "version": "https://jsonfeed.org/version/1",
    "title": "Clark Cui",
    "home_page_url": "https://clark-cui.top/",
    "feed_url": "https://clark-cui.top/feed.json",
    "description": "Clark Cui' Blog",
    "icon": "https://clark-cui.top/horse.svg",
    "author": {
        "name": "Clark Cui",
        "url": "https://clark-cui.top"
    },
    "items": [
        {
            "content_html": "<h2>对 Vue 框架的理解</h2>\n<h3>Vue 是什么?</h3>\n<p>Vue 是一个<strong>响应式</strong>的、<strong>数据驱动</strong>的 JavaScript 框架。</p>\n<h3>Vue 为什么出现？Vue 的出现解决了什么问题？</h3>\n<p>在 Vue 这种响应式的框架出现之前，前端大致经历了几个发展阶段：</p>\n<ol>\n<li>完全静态页面时期，前端展示的内容通常只是一个静态的页面，没有什么动态特性</li>\n<li>早期的服务端渲染时期，以 jsp、asp、php 这种在服务端组织 HTML 代码为主的形式，前后端通常不分离，前端的工作包含在后端之中</li>\n<li>JQuery + Ajax 时期，Ajax 的出现，也促使了前后端的分离，这时候前端可以通过 Ajax 的形式动态的从服务器获取内容，然后使用 JQuery 之类的库将获取到的数据通过 Dom 操作的形式更新到页面上</li>\n<li>现代 JavaScript 框架时期，Angular、React、Vue 等响应式框架出现，前端可以从 Dom 操作中分离，只关心数据和视图，响应式框架负责 Dom Diff（或脏检查）和更新</li>\n</ol>\n<p>Vue 等响应式框架的出现，<strong>解决的是原来前端需要频繁的通过 JQuery 或者原生 api 操作 Dom 来更新界面的问题</strong>，Vue 等响应式框架出现后，前端可以<strong>从 Dom 操作中分离出来，只需要关注数据和视图</strong>就可以了。</p>\n<h3>Vue 如何实现的响应式和数据驱动？</h3>\n<p>Vue 的响应式是通过<strong>数据劫持</strong>的相关 api 来实现的，2.0 是<code>Object.defineProperty</code>,3.0 是<code>Proxy</code>，数据驱动是通过<strong>观察者模式</strong>模式来实现的。</p>\n<h2>对 Vue 中双向绑定的理解</h2>\n<h3>什么是双向绑定？</h3>\n<p>双向绑定指的是，当数据模型发生改变时，对应的视图也会自动发生改变，反过来，当视图有变化时，数据模型也会随之改变。</p>\n<h3>双向绑定的实现？</h3>\n<p>主要是通过<strong>数据劫持</strong>和<strong>事件监听</strong></p>\n<p>通过拦截数据模型的访问和修改，实现数据的自动同步。通过监听视图中的用户输入事件（如 input、change 等），实现视图到数据模型的同步。</p>\n<h2>对 SPA（单页面应用）的理解</h2>\n<h3>什么是 SPA？</h3>\n<p>SPA（Single Page Application，单页应用）是一种 Web 应用程序的设计模式，它通过动态加载内容来实现页面的无刷新更新。SPA 的核心思想是在用户与应用程序交互时，只加载和更新必要的部分内容，而不是整个页面。这种设计模式可以提供更流畅的用户体验，减少页面加载时间，并提高应用程序的响应速度。</p>\n<h3>SPA 的特点？</h3>\n<ol>\n<li>\n<p><strong>无刷新页面更新</strong>：SPA 通过动态加载内容来实现页面的无刷新更新，用户在浏览应用程序时不会看到页面重新加载的过程。</p>\n</li>\n<li>\n<p><strong>前端路由</strong>：SPA 通常使用前端路由（Front-End Routing）来管理页面导航。前端路由通过 JavaScript 来处理 URL 的变化，并根据 URL 加载相应的页面内容。</p>\n</li>\n<li>\n<p><strong>前后端分离</strong>：SPA 通常采用前后端分离的架构，前端负责页面渲染和用户交互，后端负责提供数据和服务。</p>\n</li>\n<li>\n<p><strong>动态内容加载</strong>：SPA 通过 AJAX、Fetch API 等技术动态加载内容，而不是通过传统的页面刷新来加载内容。</p>\n</li>\n</ol>\n<h3>SPA 的实现？</h3>\n<p>SPA 的实现<br>\nSPA 的实现通常依赖于以下几个核心技术：</p>\n<ul>\n<li>\n<p><strong>前端框架</strong>：如 React、Vue.js、Angular 等，这些框架提供了组件化开发、状态管理和前端路由等功能，帮助开发者构建复杂的 SPA。</p>\n</li>\n<li>\n<p><strong>前端路由</strong>：如 React Router、Vue Router、Angular Router 等，这些库提供了前端路由功能，帮助开发者管理页面导航和 URL 变化。</p>\n</li>\n<li>\n<p><strong>AJAX/Fetch API</strong>：用于动态加载数据，实现页面的无刷新更新。</p>\n</li>\n<li>\n<p><strong>状态管理</strong>：如 Redux、Vuex、MobX 等，用于管理应用程序的状态，确保状态的一致性和可预测性。</p>\n</li>\n</ul>\n<h2>为什么 Vue 中的 data 属性是一个函数而不是一个对象？</h2>\n<p><strong>避免</strong>在组件重用时，多个组件实例共享一个数据对象，进而导致<strong>如果一个实例改变了 data 中的某个值，所有其他的实例也会受到影响的行为</strong>。</p>\n<h2>Vue 组件之间传值有几种方式？</h2>\n<h3>1. 父子组件之间传值</h3>\n<h4>父传子 - props</h4>\n<pre><code class=\"language-html\">&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n\t&lt;ChildComponent :message=&quot;parentMessage&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\timport ChildComponent from './ChildComponent.vue'\n\texport default {\n\t\tcomponents: {\n\t\t\tChildComponent\n\t\t},\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tparentMessage: 'Hello from Parent!'\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- 子组件 --&gt;\n&lt;template&gt;\n\t&lt;div&gt;{{ message }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tprops: {\n\t\t\tmessage: {\n\t\t\t\ttype: String\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n</code></pre>\n<h4>子传父 - $emit</h4>\n<pre><code class=\"language-html\">&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n\t&lt;ChildComponent @child-event=&quot;handleEvent&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\timport ChildComponent from './ChildComponent.vue'\n\texport default {\n\t\tcomponents: {\n\t\t\tChildComponent\n\t\t},\n\t\tmethods: {\n\t\t\thandleEvent(data) {\n\t\t\t\tconsole.log(data) // 接收到的数据\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- 子组件 --&gt;\n&lt;template&gt;\n\t&lt;button @click=&quot;sendData&quot;&gt;Send Data&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tmethods: {\n\t\t\tsendData() {\n\t\t\t\tthis.$emit('child-event', 'Hello from Child!')\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n</code></pre>\n<h3>2. 兄弟组件之间传值</h3>\n<h4>通过父组件作为中介（使用父组件的状态和方法）</h4>\n<pre><code class=\"language-html\">&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n\t&lt;SiblingA @updateParentState=&quot;updateState&quot; /&gt;\n\t&lt;SiblingB :state=&quot;parentState&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\timport SiblingA from './SiblingA.vue'\n\timport SiblingB from './SiblingB.vue'\n\n\texport default {\n\t\tcomponents: {\n\t\t\tSiblingA,\n\t\t\tSiblingB\n\t\t},\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tparentState: ''\n\t\t\t}\n\t\t},\n\t\tmethods: {\n\t\t\tupdateState(newState) {\n\t\t\t\tthis.parentState = newState\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- SiblingA --&gt;\n&lt;template&gt;\n\t&lt;button @click=&quot;updateState&quot;&gt;Update State&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tmethods: {\n\t\t\tupdateState() {\n\t\t\t\tthis.$emit('updateParentState', 'New State')\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- SiblingB --&gt;\n&lt;template&gt;\n\t&lt;div&gt;{{ state }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tprops: {\n\t\t\tstate: String\n\t\t}\n\t}\n&lt;/script&gt;\n</code></pre>\n<h3>3. 全局事件总线</h3>\n<h4>创建一个全局的 Vue 实例作为事件中心，用于非父子关系的组件间通信。</h4>\n<pre><code class=\"language-js\">// eventBus.js\nimport Vue from 'vue';\nexport const EventBus = new Vue();\n\n// 组件 A\nimport { EventBus } from './eventBus';\n\nexport default {\n  methods: {\n    sendData() {\n      EventBus.$emit('global-event', 'Hello from Component A!');\n    }\n  }\n};\n\n// 组件 B\nimport { EventBus } from './eventBus';\n\nexport default {\n  created() {\n    EventBus.$on('global-event', this.handleEvent);\n  },\n  beforeDestroy() {\n    EventBus.$off('global-event', this.handleEvent);\n  },\n  methods: {\n    handleEvent(data) {\n      console.log(data); // 接收到的数据\n    }\n  }\n};\n</code></pre>\n<h3>4. 全局状态管理（Vuex）</h3>\n<pre><code class=\"language-js\">// store.js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n\tstate: {\n\t\tcount: 0\n\t},\n\tmutations: {\n\t\tincrement(state) {\n\t\t\tstate.count++\n\t\t}\n\t},\n\tactions: {\n\t\tincrement({ commit }) {\n\t\t\tcommit('increment')\n\t\t}\n\t},\n\tgetters: {\n\t\tgetCount: state =&gt; state.count\n\t}\n})\n\n// main.js\nimport Vue from 'vue'\nimport App from './App.vue'\nimport store from './store'\n\nnew Vue({\n\tstore,\n\trender: h =&gt; h(App)\n}).$mount('#app')\n</code></pre>\n<pre><code class=\"language-html\">// 组件中使用\n&lt;template&gt;\n\t&lt;div&gt;{{ $store.getters.getCount }}&lt;/div&gt;\n\t&lt;button @click=&quot;$store.dispatch('increment')&quot;&gt;Increment&lt;/button&gt;\n&lt;/template&gt;\n</code></pre>\n<h3>5. ref 引用</h3>\n<h4>父组件可以通过 ref 属性引用子组件，并通过 $refs 访问子组件实例。</h4>\n<pre><code class=\"language-html\">&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n\t&lt;ChildComponent ref=&quot;child&quot; /&gt;\n\t&lt;button @click=&quot;callChildMethod&quot;&gt;Call Child Method&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\timport ChildComponent from './ChildComponent.vue'\n\texport default {\n\t\tcomponents: {\n\t\t\tChildComponent\n\t\t},\n\t\tmethods: {\n\t\t\tcallChildMethod() {\n\t\t\t\tthis.$refs.child.childMethod()\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- 子组件 --&gt;\n&lt;script&gt;\n\texport default {\n\t\tmethods: {\n\t\t\tchildMethod() {\n\t\t\t\tconsole.log('Called child method')\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n</code></pre>\n<h3>6. Provide/Inject</h3>\n<h4>上层组件通过 provide 选项提供数据，下层组件通过 inject 选项注入数据。</h4>\n<pre><code class=\"language-html\">&lt;!-- 上层组件 --&gt;\n&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;ChildComponent /&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tprovide() {\n\t\t\treturn {\n\t\t\t\tparentData: 'Hello from Parent!'\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n\n&lt;!-- 下层组件 --&gt;\n&lt;template&gt;\n\t&lt;div&gt;{{ parentData }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default {\n\t\tinject: ['parentData']\n\t}\n&lt;/script&gt;\n</code></pre>\n<h2>Vue 组件生命周期</h2>\n<p>Vue 组件的生命周期包括以下几个阶段：</p>\n<ol>\n<li><strong>beforeCreate</strong>：组件实例被创建之前调用。</li>\n<li><strong>created</strong>：组件实例被创建之后调用。</li>\n<li><strong>beforeMount</strong>：组件挂载之前调用。</li>\n<li><strong>mounted</strong>：组件挂载之后调用。</li>\n<li><strong>beforeUpdate</strong>：组件更新之前调用。</li>\n<li><strong>updated</strong>：组件更新之后调用。</li>\n<li><strong>beforeDestroy</strong>：组件销毁之前调用。</li>\n<li><strong>destroyed</strong>：组件销毁之后调用。</li>\n</ol>\n<p>父子组件触发生命周期的顺序：</p>\n<pre><code class=\"language-markdown\">挂载阶段:\n父: beforeCreate → created → beforeMount\n子: beforeCreate → created → beforeMount → mounted\n父: mounted\n\n更新阶段:\n父: beforeUpdate\n子: beforeUpdate → updated\n父: updated\n\n销毁阶段:\n父: beforeDestroy\n子: beforeDestroy → destroyed\n父: destroyed\n</code></pre>\n<p><strong>父组件总是在子组件的 mouted、updated、destroyed 生命周期函数调用之后再调用自身对应的生命周期函数，如果子组件的生命周期函数中存在异步操作，也不会等待其执行完毕，而是会立即继续执行，即：</strong></p>\n<ol>\n<li>父 mounted → 在 所有子组件 mounted 之后</li>\n<li>父 updated → 在 所有子组件 updated 之后</li>\n<li>父 destroyed → 在 所有子组件 destroyed 之后</li>\n</ol>\n<ImageBuilder :source=\"['lifecycle.jpg']\" />\n<h2>v-for 和 v-if 为什么不推荐放在一起</h2>\n<p>同时使用 v-for 和 v-if 会导致优先级不明显，在 vue2 中 v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中，造成性能浪费。</p>\n<h2>watch 和 computed 的区别</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特性</th>\n<th style=\"text-align:center\">computed</th>\n<th style=\"text-align:center\">watch</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">目的</td>\n<td style=\"text-align:center\">基于其他数据生成新的值</td>\n<td style=\"text-align:center\">监听数据的变化，并执行相应的操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">返回值</td>\n<td style=\"text-align:center\">必须</td>\n<td style=\"text-align:center\">不需要</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">缓存</td>\n<td style=\"text-align:center\">有缓存</td>\n<td style=\"text-align:center\">无缓存</td>\n</tr>\n</tbody>\n</table>\n<h2>nextTick 是什么，它的作用？</h2>\n<p><code>nextTick</code> 是 Vue 提供的异步方法，用于 <strong>​ 在下次 DOM 更新循环结束之后执行回调</strong>。它解决了数据变化后 ​ 立即操作 DOM 可能获取旧状态 ​ 的问题。</p>\n<h3>为什么需要使用 nextTick？</h3>\n<p>由于 Vue 的异步更新机制，<strong>Vue 在检测到数据变化时，不会立即更新 DOM</strong>，而是开启一个队列，缓冲同一事件循环中的所有数据变更。</p>\n",
            "url": "https://clark-cui.top/posts/前端面试题整理.html",
            "title": "前端面试题整理（一）",
            "date_modified": "2024-10-17T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>项目一：天气 app</h2>\n<ImageBuilder :source=\"['Snipaste_demo_weather.jpg']\" :size=\"'small'\"/>\n<p>项目地址：<a href=\"https://github.com/jianhua1996/flutter-weather\">https://github.com/jianhua1996/flutter-weather</a></p>\n<h2>项目二：音乐播放器</h2>\n<ImageBuilder :source=\"['Snipaste_demo_music_player.jpg', 'Snipaste_demo_music_player2.jpg', 'Snipaste_demo_music_player3.png', 'Snipaste_demo_music_player5.jpg']\" :size=\"'small'\"/>\n<p>项目地址：<a href=\"https://github.com/jianhua1996/flutter-music-player\">https://github.com/jianhua1996/flutter-music-player</a></p>\n",
            "url": "https://clark-cui.top/posts/Flutter小项目展示.html",
            "title": "Flutter小项目展示",
            "date_modified": "2024-10-09T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>1. Card 组件</h2>\n<p>Card 组件是 Flutter 中最常用的组件之一，它可以用来显示一些内容，<strong>它的默认样式是一个略微圆角且带有阴影凸起的面板</strong>，Card 组件可以包含一个子组件，也可以没有子组件。Card 组件的主要属性有：</p>\n<ul>\n<li>color：Card 组件的背景颜色。</li>\n<li>elevation：Card 组件的阴影大小。</li>\n<li>shape：Card 组件的形状。</li>\n<li>clipBehavior：Card 组件的裁剪行为。</li>\n<li>child：Card 组件的子组件。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/material/Card-class.html\">查看更多属性</a></p>\n<p>Card 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">Card(\n  color: Colors.blue,\n  elevation: 10,\n  child: Padding(\n    padding: const EdgeInsets.all(8.0),\n    child: Text(\n      'This is a card',\n      style: TextStyle(color: Colors.white),\n    ),\n  ),\n),\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_card.png']\" />\n<h2>2. ListTile 组件</h2>\n<p>ListTile 组件是 Flutter 中用来显示列表项的组件，通常与 Listview 组件、Card 组件等一起搭配使用，它可以<strong>用来展示一个标题、一段描述、一张图片或者一个小部件</strong>，ListTile 组件的主要属性有：</p>\n<ul>\n<li>leading：ListTile 组件的左侧组件，通常是一个小部件。</li>\n<li>title：ListTile 组件的标题。</li>\n<li>subtitle：ListTile 组件的副标题。</li>\n<li>trailing：ListTile 组件的右侧组件，通常是一个小部件。</li>\n<li>dense：ListTile 组件是否显示为紧凑模式。</li>\n<li>enabled：ListTile 组件是否可以点击。</li>\n<li>onTap：ListTile 组件的点击事件。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/material/ListTile-class.html\">查看更多属性</a></p>\n<p>ListTile 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">ListTile(\n  leading: Icon(Icons.person),\n  title: Text('标题'),\n  subtitle: Text('子标题'),\n  trailing: Icon(Icons.arrow_forward),\n  dense: true,\n  enabled: true,\n  onTap: () {\n    print('ListTile 被点击了');\n  },\n)\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_listtile.png']\" />\n<h2>3. CircleAvatar 组件</h2>\n<p>CircleAvatar 组件是一个圆形的头像组件，它可以<strong>用来显示用户头像或者其他圆形的图片</strong>，CircleAvatar 组件的主要属性有：</p>\n<ul>\n<li>backgroundImage：CircleAvatar 组件的背景图片。</li>\n<li>backgroundColor：CircleAvatar 组件的背景颜色。</li>\n<li>foregroundColor：CircleAvatar 组件的前景颜色。</li>\n<li>radius：CircleAvatar 组件的圆角半径。</li>\n<li>child：CircleAvatar 组件的子组件。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/material/CircleAvatar-class.html\">查看更多属性</a></p>\n<p>CircleAvatar 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">CircleAvatar(\n  backgroundImage:\n      const NetworkImage('https://www.example.com/example.jpg'),\n  backgroundColor: Colors.lightGreen.shade100,\n  radius: 50,\n  child: const FlutterLogo(\n    size: 50,\n  ),\n),\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_circleavatar.jpg']\" />\n<h2>4. Divider 组件</h2>\n<p>Divider 组件是一个分割线组件，它可以<strong>用来分隔不同列表项或者不同区域</strong>，Divider 组件的主要属性有：</p>\n<ul>\n<li>height：Divider 组件的高度。</li>\n<li>thickness：Divider 组件的粗细。</li>\n<li>indent：Divider 组件距离左侧距离。</li>\n<li>endIndent：Divider 组件距离右侧距离。</li>\n<li>color：Divider 组件的颜色。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/material/Divider-class.html\">查看更多属性</a></p>\n<p>Divider 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">Column(\n  children: [\n    CircleAvatar(\n      backgroundImage:\n          const NetworkImage('https://www.example.com/example.jpg'),\n      backgroundColor: Colors.lightGreen.shade100,\n      radius: 50,\n      child: const FlutterLogo(\n        size: 50,\n      ),\n    ),\n    const Divider(\n      height: 10,\n      thickness: 2,\n      indent: 10,\n      endIndent: 10,\n      color: Colors.pink,\n    ),\n  ],\n)\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_divider.png']\" />\n<h2>5. ElevatedButton 组件</h2>\n<p>ElevatedButton 组件是一个<strong>带有阴影的按钮组件</strong>，它可以<strong>用来触发一些重要的操作，比如提交表单、打开新页面</strong>等，ElevatedButton 组件的主要属性有：</p>\n<ul>\n<li>onPressed：按钮点击事件。</li>\n<li>style：按钮样式。</li>\n<li>child：按钮子组件。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/material/ElevatedButton-class.html\">查看更多属性</a></p>\n<p>ElevatedButton 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">ElevatedButton(\n  onPressed: () {\n    print('按钮被点击了');\n  },\n  style: ElevatedButton.styleFrom(\n    foregroundColor: Colors.white,\n    backgroundColor: Colors.blue,\n    shadowColor: Colors.blue.shade700,\n    elevation: 12,\n  ),\n  child: Text('按钮'),\n),\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_elevatedbutton.png']\" />\n<h2>6. GestureDetector 组件</h2>\n<p>GestureDetector 组件是一个<strong>手势监听器组件</strong>，它可以<strong>用来监听用户的手势操作，比如滑动、点击、长按等</strong>，GestureDetector 组件的主要属性有：</p>\n<ul>\n<li>onTap：手指单击事件。</li>\n<li>onDoubleTap：手指双击事件。</li>\n<li>onLongPress：手指长按事件。</li>\n<li>child：手势监听器子组件。</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/widgets/GestureDetector-class.html\">查看更多属性</a></p>\n<p>GestureDetector 组件的示例代码如下：</p>\n<pre><code class=\"language-dart\">GestureDetector(\n  onTap: () {\n    print('手指单击了');\n  },\n  onDoubleTap: () {\n    print('手指双击了');\n  },\n  onLongPress: () {\n    print('手指长按了');\n  },\n  child: Container(\n    width: 100,\n    height: 100,\n    color: Colors.blue,\n  ),\n),\n</code></pre>\n<p>效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_gesturedetector.jpg']\" />\n",
            "url": "https://clark-cui.top/posts/Flutter组件学习（二）.html",
            "title": "Flutter组件学习（二）",
            "date_modified": "2024-10-06T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>1. Container 组件</h2>\n<p>Container 组件是 Flutter 中的<code>布局组件</code>，可以类比为 web 开发中的 div 标签。</p>\n<p>它属于单一子组件的容器，接受<code>一个</code> child 参数作为子组件， child 类型<strong>可以是任何 widget，包括其他的 Container 组件</strong>。</p>\n<p><strong>容器在没有子元素的情况下会尽量变得尽可能大，除非传入的约束条件是无界的</strong>，在这种情况下，它们会尽量变得尽可能小。</p>\n<pre><code class=\"language-dart\">Container(\n  decoration: BoxDecoration(\n    color: Colors.blue,\n  ),\n)\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_container1.png']\" />\n<p><strong>有子元素的容器会根据其子元素的大小来调整自身大小</strong>。</p>\n<pre><code class=\"language-dart\">Container(\n  decoration: BoxDecoration(\n    color: Colors.blue,\n  ),\n  child: Text('Hello World!'),\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_container2.png']\" />\n<blockquote>\n<p>Tips: 如果你希望所有的元素都在安全区域展示，不被系统状态栏、导航栏等系统元素遮挡，可以使用 SafeArea 组件。</p>\n</blockquote>\n<pre><code class=\"language-dart\">SafeArea(\n  child: Container(\n    decoration: BoxDecoration(\n      color: Colors.blue,\n    ),\n    child: Text('Hello World!'),\n  ),\n)\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_container3.png']\" />\n<p>如果你给 Container 组件设置了 width 和 height，那么它将会按照你指定的尺寸而不是子组件的尺寸来进行布局。</p>\n<pre><code class=\"language-dart\">SafeArea(\n  child: Container(\n    decoration: BoxDecoration(\n      color: Colors.blue,\n    ),\n    width: 100,\n    height: 100,\n    child: Text('Hello World!'),\n  ),\n)\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_container4.png']\" />\n<h3>1.1 关于外边距（magin）和内边距（padding）</h3>\n<p>container 组件可以通过 margin 和 padding 属性来设置外边距和内边距。（flutter 中外边距和内边距的概念等同于 web 开发中的 margin 和 padding）</p>\n<p>生成内外边距的方法：</p>\n<ul>\n<li>EdgeInsets.all 生成四个方向上都相同的内外边距</li>\n<li>EdgeInsets.symmetric 按照水平或垂直方向生成内外边距</li>\n<li>EdgeInsets.fromLTRB 按照左、上、右、下四个方向生成内外边距</li>\n<li>EdgeInsets.only 按照指定方向生成内外边距</li>\n</ul>\n<pre><code class=\"language-dart\">SafeArea(\n  child: Container(\n    // margin: EdgeInsets.all(10),\n    // padding: EdgeInsets.symmetric(horizontal: 20, vertical: 10),\n    margin: const EdgeInsets.fromLTRB(10, 10, 10, 10),\n    padding:\n        const EdgeInsets.only(left: 20, top: 10, right: 20, bottom: 10),\n    decoration: const BoxDecoration(\n      color: Colors.blue,\n    ),\n    width: 100,\n    height: 100,\n    child: const Text('Hello World!'),\n  ),\n),\n\n</code></pre>\n<h2>2. Rows 和 Columns 组件</h2>\n<p>Rows 和 Columns 组件同样是 Flutter 中的<code>布局组件</code>，可以类比为 web 开发中的 flex 布局。</p>\n<p>它们都属于多子组件的容器，接受<code>多个</code> child 参数作为子组件，入口参数为<code>children</code>， children 指定的子组件类型<strong>可以是任何 widget 或 widget 集合，包括其他的 Rows 和 Columns 组件</strong>。</p>\n<pre><code class=\"language-dart\">SafeArea(\n  child: Column(\n    children: [\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.blue,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.yellow,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.green,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n    ],\n  ),\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_rows_columns.jpg']\" />\n<p><strong>Columns 组件总是会在垂直方向上尽可能的占用空间，而 Rows 组件总是在水平方向上尽可能的占用空间。</strong></p>\n<p>如图所示：</p>\n<ImageBuilder :source=\"['Snipaste_phone_rows_columns2.png']\" />\n<blockquote>\n<p>如果你希望更改这个默认行为，可以通过更改 mainAxisSize 属性来控制 Rows 和 Columns 组件在主轴方向上的尺寸分配。</p>\n<pre><code class=\"language-dart\">Column(\n  mainAxisSize: MainAxisSize.min,\n)\n</code></pre>\n</blockquote>\n<p>另外，Columns 组件还可以设置 verticalDirection 属性来控制子组件的排列方向。</p>\n<pre><code class=\"language-dart\">\nSafeArea(\n  child: Column(\n    // mainAxisSize: MainAxisSize.min,\n    verticalDirection: VerticalDirection.up,\n    children: [\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.blue,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.yellow,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n      Container(\n        decoration: const BoxDecoration(\n          color: Colors.green,\n        ),\n        width: 100,\n        height: 100,\n        child: const Text('Hello World!'),\n      ),\n    ],\n  ),\n)\n\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_rows_columns3.jpg']\" />\n<p>以及，通过 <code>mainAxisAlignment</code> 属性来控制子组件在主轴方向上的对齐方式，有效的值有：</p>\n<ul>\n<li>MainAxisAlignment.start</li>\n<li>MainAxisAlignment.end</li>\n<li>MainAxisAlignment.center</li>\n<li>MainAxisAlignment.spaceBetween</li>\n<li>MainAxisAlignment.spaceAround</li>\n<li>MainAxisAlignment.spaceEvenly 子组件间距均匀分布</li>\n</ul>\n<p>通过 <code>crossAxisAlignment</code> 属性来控制子组件在交叉轴方向上的对齐方式，有效的值有：</p>\n<ul>\n<li>CrossAxisAlignment.start</li>\n<li>CrossAxisAlignment.end</li>\n<li>CrossAxisAlignment.center</li>\n<li>CrossAxisAlignment.stretch 拉伸子组件，占满交叉轴方向的全部空间</li>\n<li>CrossAxisAlignment.baseline</li>\n</ul>\n<p><strong>这些基本上和 web 开发中的 flex 布局的概念是一致的， mainAxisAlignment 和 crossAxisAlignment 也和 justify-content 和 align-items 相对应</strong></p>\n<h2>3. Image 组件与图片导入</h2>\n<p>Image 组件是 Flutter 中的<code>图片组件</code>，用来展示图片。</p>\n<p>它提供多种构造函数，用于指定加载图像的多种方式：</p>\n<ul>\n<li>Image.asset 加载本地资源图片</li>\n<li>Image.network 加载网络图片</li>\n<li>Image.file 加载本地文件图片</li>\n</ul>\n<p><a href=\"https://api.flutter-io.cn/flutter/widgets/Image-class.html\">查看上述方式的详细用法</a></p>\n<p>Image 组件支持的图片格式有： <strong>JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP</strong>。</p>\n<p>在默认的构造函数中，通过<code>image</code>参数传入一个指定的<code>ImageProvider</code>类型的值，就可以加载指定的图片。</p>\n<p><code>ImageProvider</code> 是一个抽象类，用于提供图片资源。常见的 ImageProvider 类型有 <code>AssetImage</code>、<code>NetworkImage</code>、<code>FileImage</code> 等。</p>\n<pre><code class=\"language-dart\"> Image(\n  image: AssetImage('assets/images/xxx.png'),\n  width: 100,\n  height: 100,\n),\n</code></pre>\n<blockquote>\n<p>需要注意的是，在使用<code>AssetImage</code>类型的<code>ImageProvider</code>时，需要先在 pubspec.yaml 文件中配置图片资源路径来导入图片资源。</p>\n<ImageBuilder :source=\"['Snipaste_phone_image.png']\" />\n</blockquote>\n<h2>4. Text 组件与自定义字体</h2>\n<p>Text 组件是 Flutter 中的<code>文本组件</code>，用来展示文本。</p>\n<p>通过指定<code>style</code>参数，可以设置文本的字体大小、颜色、粗细、斜体等样式。<a href=\"https://api.flutter-io.cn/flutter/widgets/Text-class.html\">查看更多样式设置</a></p>\n<pre><code class=\"language-dart\">Text(\n  'Hello World!',\n  style: TextStyle(\n    fontSize: 20,\n    color: Colors.blue,\n    fontWeight: FontWeight.bold,\n    fontStyle: FontStyle.italic,\n  ),\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_text.png']\" />\n<h3>4.1 自定义字体</h3>\n<p>Flutter 支持自定义字体，通过 <code>fontFamily</code> 参数指定字体名称，就可以使用该字体渲染文本。</p>\n<pre><code class=\"language-dart\">const Text(\n  'Hello World!',\n  style: TextStyle(\n    fontSize: 20,\n    color: Colors.blue,\n    fontWeight: FontWeight.bold,\n    fontStyle: FontStyle.italic,\n    fontFamily: 'PlaywriteDEGrund',\n  ),\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_custom_font2.png']\" />\n<blockquote>\n<p>需要注意的是，自定义字体同样需要在 pubspec.yaml 文件中配置和导入。</p>\n<ImageBuilder :source=\"['Snipaste_phone_custom_font.png']\" />\n</blockquote>\n<h2>5. Icon 组件</h2>\n<p>Icon 组件是 Flutter 中的<code>图标组件</code>，用来展示具体的图标类型。</p>\n<p>通常的做法是<strong>通过指定 flutter 中预定义的 material IconData 枚举值来展示具体的图标</strong>。<a href=\"https://api.flutter-io.cn/flutter/material/Icons-class.html\">查看所有图标类型</a></p>\n<pre><code class=\"language-dart\">Icon(\n  Icons.favorite,\n  size: 30,\n  color: Colors.red,\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_icon.png']\" />\n<h2>6. Expanded 组件</h2>\n<p>Expanded 组件同样是 Flutter 中的<code>布局组件</code>，它可以用来扩展其子组件的尺寸。</p>\n<p>使用 <strong>Expanded 组件可以使 Row、Column 或 Flex 布局的子元素沿着主轴扩展以填充可用空间</strong>（例如，对于 Row 是水平扩展，对于 Column 是垂直扩展）。<strong>如果有多个子元素扩展，可用空间将根据弹性因子<code>flex</code>按比例在它们之间进行分配</strong>。</p>\n<blockquote>\n<p>注意： Expanded 组件只能作为 Row、Column 或 Flex 布局的子元素使用。</p>\n</blockquote>\n<p><a href=\"https://api.flutter-io.cn/flutter/widgets/Expanded-class.html\">查看更多 Expanded 组件用法</a></p>\n<pre><code class=\"language-dart\">Row(\n  children: [\n    Expanded(\n      flex: 2, // 比例因子\n      child: Container(\n        decoration: BoxDecoration(\n          color: Colors.blue,\n        ),\n        width: 100, // 这里设置的宽度不会生效\n        height: 100,\n        child: Text('Hello World!'),\n      ),\n    ),\n    Expanded(\n      child: Container(\n        decoration: BoxDecoration(\n          color: Colors.yellow,\n        ),\n        width: 100, // 这里设置的宽度不会生效\n        height: 100,\n        child: Text('Hello World!'),\n      ),\n    ),\n    Expanded(\n      flex: 2, // 比例因子\n      child: Container(\n        decoration: BoxDecoration(\n          color: Colors.green,\n        ),\n        width: 100, // 这里设置的宽度不会生效\n        height: 100,\n        child: Text('Hello World!'),\n      ),\n    ),\n  ],\n),\n</code></pre>\n<p>以上代码效果如下：</p>\n<ImageBuilder :source=\"['Snipaste_phone_expanded.png']\" />\n<h2>7. Padding 组件</h2>\n<p>Padding 组件也是 Flutter 中的<code>布局组件</code>之一，用来给父组件添加内边距。</p>\n<p>它接受<code>一个</code> padding 参数，该参数是一个<code>EdgeInsetsGeometry</code>类型的值，用来设置四个方向上的内边距。</p>\n<p>具体用法和 Container 组件中的 padding 属性类似。<a href=\"#_1-1-%E5%85%B3%E4%BA%8E%E5%A4%96%E8%BE%B9%E8%B7%9D-magin-%E5%92%8C%E5%86%85%E8%BE%B9%E8%B7%9D-padding\">回到 1.1</a></p>\n<p><a href=\"https://api.flutter-io.cn/flutter/widgets/Padding-class.html\">更多 Padding 组件用法</a></p>\n<pre><code class=\"language-dart\">Padding(\n  padding: const EdgeInsets.all(20),\n  child: Container(\n    decoration: BoxDecoration(\n      color: Colors.blue,\n    ),\n    width: 100,\n    height: 100,\n    child: Text('Hello World!'),\n  ),\n),\n</code></pre>\n",
            "url": "https://clark-cui.top/posts/Flutter组件学习（一）.html",
            "title": "Flutter组件学习（一）",
            "date_modified": "2024-10-04T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>浏览器的进程模型</h2>\n<h3>进程与线程</h3>\n<p>进程是正在运行的<u>程序的实例</u>，每个进程都有自己<u>独立的</u>一块内存空间，有了进程之后，才可以运行程序的代码。一个进程至少有一个线程，叫做主线程，一个进程也可以运行多个线程，多个线程可以共享数据。</p>\n<h3>浏览器是一个多进程多线程的应用程序</h3>\n<p>浏览器是一个极其复杂的应用程序</p>\n<p>为了避免多个功能之间的相互影响，减少崩溃的几率，浏览器在启动的时候会启动多个进程。</p>\n<p><strong>其中，最主要的进程有</strong>：</p>\n<ol>\n<li>\n<p><strong>浏览器进程</strong></p>\n<p>负责界面显示、用户交互、子进程管理等。</p>\n</li>\n<li>\n<p><strong>网络进程</strong></p>\n<p>负责网络通信，各种资源的加载。</p>\n</li>\n<li>\n<p><strong>渲染进程</strong></p>\n<p>每个标签页都是一个新的渲染进程，渲染进程的主线程负责执行 HTML、CSS、JS 代码</p>\n</li>\n</ol>\n<h3>渲染主线程是如何工作的</h3>\n<p>渲染主线程是浏览器中最繁忙的线程，它处理的任务包括：</p>\n<ul>\n<li>\n<p>解析 html</p>\n</li>\n<li>\n<p>解析 css</p>\n</li>\n<li>\n<p>计算样式</p>\n</li>\n<li>\n<p>布局</p>\n</li>\n<li>\n<p>处理图层</p>\n</li>\n<li>\n<p>每秒把页面画 60 次</p>\n</li>\n<li>\n<p>执行全局 js 代码</p>\n</li>\n<li>\n<p>处理事件函数</p>\n</li>\n<li>\n<p>执行计时器的回调</p>\n</li>\n<li>\n<p>......</p>\n</li>\n</ul>\n<p>为了处理这么多任务的调度，主线程想出了一个办法：队列</p>\n<p>当渲染<u>主线程正在执行任务</u>时，由渲染主线程和浏览器<u>其他</u>线程安排的<u>任务</u>会被暂时放<u>到队列中等待执行</u>，当渲染<u>主线程中的任务执行完毕</u>，会<u>从队列中依次取出</u>排队的任务进行<u>执行</u>。</p>\n<ol>\n<li>\n<p>在最开始的时候，渲染主线程会进入一个无线循环</p>\n<pre><code class=\"language-cpp\">for(;;){\n\n}\n</code></pre>\n</li>\n<li>\n<p>每一次循环会检查队列中是否有任务存在，如果有，就取出第一个任务进行执行，执行完后进入下一次循环；如果没有，则进入休眠状态。</p>\n</li>\n<li>\n<p>其他所有的线程（包括其他进程的线程）可以随时向队列添加任务，新添加的任务会被放到队列的末尾。添加任务时，如果主线程是休眠状态，则唤醒</p>\n</li>\n</ol>\n<h3>何为异步？</h3>\n<p>在代码执行的过程中，无法立即处理（需要等待）的任务就是异步任务，比如：</p>\n<ul>\n<li>\n<p>计时器安排的任务 <code>setTimeout</code>、<code>setInterval</code></p>\n</li>\n<li>\n<p>网络通信后执行的任务 <code>XHR</code>、<code>fetch</code></p>\n</li>\n<li>\n<p>用户操作后执行的任务 <code>addEventListner</code></p>\n</li>\n</ul>\n<p>渲染主线程不会等待以上任务的执行，而是继续执行主线程需要执行的代码。当以上任务（由浏览器的其他进程）执行完成时，会把执行后的结果放到队列中进行等待（直到主线程清空后依次从队列中取出）。</p>\n<h3>JS 代码为何会阻塞渲染</h3>\n<p>因为 js 代码和页面渲染都会在渲染主线程中进行执行，而页面的重绘是异步的过程，需要等待主线程的 js 代码执行完毕。</p>\n<h3>队列中的任务有优先级吗？</h3>\n<p>队列中的任务没有优先级，都是先进先出</p>\n<p>但是<u>队列有优先级</u></p>\n<ul>\n<li>\n<p>每个任务都有一个任务类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同队列中取出任务执行</p>\n</li>\n<li>\n<p>浏览器必须准备好一个微队列，<u>微队列中的任务优先于其他所有任务执行</u>（btw:微队列，vip 的 v）</p>\n<p>添加任务到微队列的方式 <code>Promsie</code> 和<code>MutationObserver</code></p>\n<pre><code class=\"language-javascript\">// 立刻把一个函数放到微队列\nPromise.resolve().then(函数)\n</code></pre>\n</li>\n</ul>\n",
            "url": "https://clark-cui.top/posts/事件循环.html",
            "title": "事件循环",
            "date_modified": "2024-03-12T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>浏览器是如何渲染页面的</h2>\n<h3>什么是渲染</h3>\n<p>把 html 字符串转换为像素点信息的过程就可以叫做渲染</p>\n<h3>渲染的开始</h3>\n<p>当浏览器的网络线程拿到 HTML 文档后，会产生一个渲染任务，并将其放到队列中。</p>\n<p>在事件循环机制的作用下，渲染主线程取出队列中的渲染任务，开启渲染流程。</p>\n<h3>渲染流水线</h3>\n<ol>\n<li>\n<p>解析 HTML 文档</p>\n</li>\n<li>\n<p>样式计算</p>\n</li>\n<li>\n<p>布局</p>\n</li>\n<li>\n<p>分层</p>\n</li>\n<li>\n<p>绘制</p>\n</li>\n<li>\n<p>分块</p>\n</li>\n<li>\n<p>光栅化</p>\n</li>\n<li>\n<p>画</p>\n</li>\n</ol>\n<h3>1. 解析 HTML - Parse HTML</h3>\n<p>最终结果是把 html 文档转换成<code>DOM树(文档对象模型)</code>和<code>CSSOM树(CSS 对象模型)</code></p>\n<p>渲染的第一步是解析 html。</p>\n<p>解析过程中<u>遇到 css 解析 css</u>，<u>遇到 js 执行 js</u>。为了提高解析效率，浏览器在开始解析前，会启动一个<u>预解析的线程</u>，率先<u>下载</u>html 中的<u>外部 css 文件</u>和<u>外部的 js 文件</u>。</p>\n<p>如果主线程解析到 link 位置，此时外部的 css 文件还没有下载解析好，主线程不会等待，继续后续 html 的解析。这就是<u>css 不会阻塞 html 解析</u>的根本原因。</p>\n<p>如果主线程解析到 script 位置，会停止解析 html，转而执行 js 代码或者等待 js 文件下载完毕并执行后，才继续解析 html。这是因为，<u>js 代码执行的过程中可能会修改当前构建好的 dom</u>树，所以必须先暂停解析。<u>这就是 js 会阻塞 html 解析的根本原因</u>。</p>\n<p>第一步完成后，会得到 dom 树和 cssom 树，浏览器的默认样式会包含在 cssom 树中。</p>\n<h3>2. 样式计算 - Recalculate Style</h3>\n<p>主线程会遍历得到的 dom 树，依次为树中的每个节点计算出它最终的样式，称之为<code>Computed Style</code>。</p>\n<p>在这一过程中，很多预设值会变成绝对值，比如 red 会变成 rgb(255,0,0)；相对单位会变成绝对单位，比如 em 会变成 px</p>\n<h3>3. 布局 - Layout</h3>\n<p>主线程在进行 layout 计算的时候也会生成相应的 layout 树，需要注意的是，<u>dom 树和 layout 树并不是一一对应的</u>。</p>\n<p>比如<code>display: none</code>的节点没有几何信息，因此不会生成到布局树；又比如一些伪元素在 dom 节点中不存在，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等这些都会导致 dom 树和布局树无法一一对应。</p>\n<h3>4. 分层 - Layer</h3>\n<p>主线程会使用一套复杂的策略对整个布局树进行分层。</p>\n<p>分层的好处是，如果一个节点经常进行变动，则只需要对该层进行后续处理，而不需要对整个树进行处理，提升了效率。</p>\n<p><u>可以通过<code>will-change</code>属性主动影响浏览器的分层结果</u>。</p>\n<h3>5. 绘制 - Paint</h3>\n<p>主线程会为每个层<u>单独生成</u>绘制指令集，用于<u>描述</u>这一层该<u>如何画出来</u>。</p>\n<h3>6. 分块 - Tiling</h3>\n<p>上一步完成后，主线程会将每个图层的绘制信息交给合成线程，剩余工作由合成线程完成。</p>\n<p>合成线程首先对每个<u>图层</u>进行<u>分块</u>，将其划分成许多的小区域。这一过程是由<u>多个线程</u>完成的。</p>\n<h3>7. 光栅化 - Raster</h3>\n<p>分块完成后，进入光栅化阶段。</p>\n<p>合成线程会将分块信息交给 gpu 进程，gpu 会以极高的速度进行光栅化。</p>\n<p><u>光栅化的结果就是一块一块的位图</u>。</p>\n<h3>8. 画 - Draw</h3>\n<p>最后一个阶段就是画</p>\n<p>合成线程从 gpu 进程中拿到每个块的位图后，生成一个个<u><code>指引（quad）</code>信息</u>。</p>\n<p>指引会标识出每个位图应该画到屏幕的哪个位置，并且会考虑旋转、缩放等变形。</p>\n<p><u>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的原因</u>。</p>\n<p>合成线程会把<code>quad</code>信息交给 gpu 进程，由 gpu 进程调用 gpu 硬件，最终完成屏幕图像的显示。</p>\n<h3>关于 reflow</h3>\n<p><u>reflow 的本质就是重新计算 layout 树</u>。</p>\n<p>当进行了影响布局树的操作后，就需要重新计算布局树，触发 layout 流程。</p>\n<p>为了避免连续多次的布局树反复计算，浏览器会合并这些操作，当 js 代码全部完成后再进行统一的布局树计算。所以，改动属性造成的 reflow 是异步完成的。</p>\n<p>也正是因为如此，当我们在更改布局属性后立即获取它们的信息，就有可能造成无法获取到最新布局信息的结果。</p>\n<p>浏览器最终在反复权衡之下，决定获取属性时立即 reflow。</p>\n<h3>关于 repaint</h3>\n<p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p>\n<p>当改动了可见样式后，就需要重新计算，触发 repaint 流程。</p>\n<p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint</p>\n",
            "url": "https://clark-cui.top/posts/浏览器渲染原理.html",
            "title": "浏览器渲染原理",
            "date_modified": "2024-03-11T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h1>测试一下呢呢</h1>\n<p>测试测试</p>\n<pre><code class=\"language-javascript\">console.log('test test')\n</code></pre>\n",
            "url": "https://clark-cui.top/posts/作为测试文章.html",
            "title": "测试文章",
            "summary": "测试测试",
            "date_modified": "2024-02-15T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        }
    ]
}