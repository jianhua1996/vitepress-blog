<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Clark Cui</title>
        <link>https://clark-cui.top/</link>
        <description>Clark Cui' Blog</description>
        <lastBuildDate>Sat, 05 Oct 2024 05:52:59 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <image>
            <title>Clark Cui</title>
            <url>https://clark-cui.top/horse.svg</url>
            <link>https://clark-cui.top/</link>
        </image>
        <copyright>MIT License</copyright>
        <atom:link href="https://clark-cui.top/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Flutter 组件学习（一）]]></title>
            <link>https://clark-cui.top/posts/Flutter 组件学习（一）.html</link>
            <guid>https://clark-cui.top/posts/Flutter 组件学习（一）.html</guid>
            <pubDate>Sat, 05 Oct 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h2>1. Container 组件</h2>
<p>Container 组件是 Flutter 中的<code>布局组件</code>，可以类比为 web 开发中的 div 标签。</p>
<p>它属于单一子组件的容器，接受<code>一个</code> child 参数作为子组件， child 类型<strong>可以是任何 widget，包括其他的 Container 组件</strong>。</p>
<p><strong>容器在没有子元素的情况下会尽量变得尽可能大，除非传入的约束条件是无界的</strong>，在这种情况下，它们会尽量变得尽可能小。</p>
<pre><code class="language-dart">Container(
  decoration: BoxDecoration(
    color: Colors.blue,
  ),
)
</code></pre>
<p>以上代码效果如下：</p>
<p><img src="../public/Snipaste_phone_container1.png" alt="图片1"></p>
<p><strong>有子元素的容器会根据其子元素的大小来调整自身大小</strong>。</p>
<pre><code class="language-dart">Container(
  decoration: BoxDecoration(
    color: Colors.blue,
  ),
  child: Text('Hello World!'),
),
</code></pre>
<p>以上代码效果如下：</p>
<p><img src="../public/Snipaste_phone_container2.png" alt="图片2"></p>
<blockquote>
<p>Tips: 如果你希望所有的元素都在安全区域展示，不被系统状态栏、导航栏等系统元素遮挡，可以使用 SafeArea 组件。</p>
</blockquote>
<pre><code class="language-dart">SafeArea(
  child: Container(
    decoration: BoxDecoration(
      color: Colors.blue,
    ),
    child: Text('Hello World!'),
  ),
)
</code></pre>
<p>以上代码效果如下：</p>
<p><img src="../public/Snipaste_phone_container3.png" alt="图片3"></p>
<p>如果你给 Container 组件设置了 width 和 height，那么它将会按照你指定的尺寸而不是子组件的尺寸来进行布局。</p>
<pre><code class="language-dart">SafeArea(
  child: Container(
    decoration: BoxDecoration(
      color: Colors.blue,
    ),
    width: 100,
    height: 100,
    child: Text('Hello World!'),
  ),
)
</code></pre>
<p>以上代码效果如下：</p>
<p><img src="../public/Snipaste_phone_container4.png" alt="图片4"></p>
<h3>1.1 关于外边距（magin）和内边距（padding）</h3>
<p>container 组件可以通过 margin 和 padding 属性来设置外边距和内边距。（flutter中外边距和内边距的概念等同于web开发中的 margin 和 padding）</p>
<p>生成内外边距的方法：</p>
<ul>
<li>EdgeInsets.all 生成四个方向上都相同的内外边距</li>
<li>EdgeInsets.symmetric 按照水平或垂直方向生成内外边距</li>
<li>EdgeInsets.fromLTRB 按照左、上、右、下四个方向生成内外边距</li>
<li>EdgeInsets.only 按照指定方向生成内外边距</li>
</ul>
<pre><code class="language-dart">SafeArea(
  child: Container(
    // margin: EdgeInsets.all(10),
    // padding: EdgeInsets.symmetric(horizontal: 20, vertical: 10),
    margin: const EdgeInsets.fromLTRB(10, 10, 10, 10),
    padding:
        const EdgeInsets.only(left: 20, top: 10, right: 20, bottom: 10),
    decoration: const BoxDecoration(
      color: Colors.blue,
    ),
    width: 100,
    height: 100,
    child: const Text('Hello World!'),
  ),
),

</code></pre>
<h2>2. Rows 和 Columns 组件</h2>
<p>Rows 和 Columns 组件同样是 Flutter 中的<code>布局组件</code>，可以类比为 web 开发中的 flex 布局。</p>
<p>它们都属于多子组件的容器，接受<code>多个</code> child 参数作为子组件，入口参数为<code>children</code>， children指定的子组件类型<strong>可以是任何 widget 或 widget 集合，包括其他的 Rows 和 Columns 组件</strong>。</p>
<pre><code class="language-dart">SafeArea(
  child: Column(
    children: [
      Container(
        decoration: const BoxDecoration(
          color: Colors.blue,
        ),
        width: 100,
        height: 100,
        child: const Text('Hello World!'),
      ),
      Container(
        decoration: const BoxDecoration(
          color: Colors.yellow,
        ),
        width: 100,
        height: 100,
        child: const Text('Hello World!'),
      ),
      Container(
        decoration: const BoxDecoration(
          color: Colors.green,
        ),
        width: 100,
        height: 100,
        child: const Text('Hello World!'),
      ),
    ],
  ),
),
</code></pre>
<p>以上代码效果如下：</p>
<p><img src="../public/Snipaste_phone_rows_columns.png" alt="图片5"></p>
<p><strong>Columns 组件总是会在垂直方向上尽可能的占用空间，而 Rows 组件总是在水平方向上尽可能的占用空间。</strong></p>
<p>如图所示：</p>
<p><img src="../public/Snipaste_phone_rows_columns2.png" alt="图片6"></p>
<blockquote>
<p>如果你希望更改这个默认行为，可以通过更改 mainAxisSize 属性来控制 Rows 和 Columns 组件在主轴方向上的尺寸分配。</p>
<pre><code class="language-dart">Column(
  mainAxisSize: MainAxisSize.min,
)
</code></pre>
</blockquote>
<p>另外，Columns 组件还可以设置 verticalDirection 属性来控制子组件的排列方向。</p>
<pre><code class="language-dart">
SafeArea(
  child: Column(
    // mainAxisSize: MainAxisSize.min,
    verticalDirection: VerticalDirection.up,
    children: [
      Container(
        decoration: const BoxDecoration(
          color: Colors.blue,
        ),
        width: 100,
        height: 100,
        child: const Text('Hello World!'),
      ),
      Container(
        decoration: const BoxDecoration(
          color: Colors.yellow,
        ),
        width: 100,
        height: 100,
        child: const Text('Hello World!'),
      ),
      Container(
        decoration: const BoxDecoration(
          color: Colors.green,
        ),
        width: 100,
        height: 100,
        child: const Text('Hello World!'),
      ),
    ],
  ),
)

</code></pre>
<p>以上代码效果如下：</p>
<p><img src="../public/Snipaste_phone_rows_columns3.png" alt="图片7"></p>
<p>以及，通过 <code>mainAxisAlignment</code> 属性来控制子组件在主轴方向上的对齐方式，有效的值有：</p>
<ul>
<li>MainAxisAlignment.start</li>
<li>MainAxisAlignment.end</li>
<li>MainAxisAlignment.center</li>
<li>MainAxisAlignment.spaceBetween</li>
<li>MainAxisAlignment.spaceAround</li>
<li>MainAxisAlignment.spaceEvenly 子组件间距均匀分布</li>
</ul>
<p>通过 <code>crossAxisAlignment</code> 属性来控制子组件在交叉轴方向上的对齐方式，有效的值有：</p>
<ul>
<li>CrossAxisAlignment.start</li>
<li>CrossAxisAlignment.end</li>
<li>CrossAxisAlignment.center</li>
<li>CrossAxisAlignment.stretch  拉伸子组件，占满交叉轴方向的全部空间</li>
<li>CrossAxisAlignment.baseline</li>
</ul>
<p><strong>这些基本上和 web 开发中的 flex 布局的概念是一致的， mainAxisAlignment 和 crossAxisAlignment 也和 justify-content 和 align-items 相对应</strong></p>
<h2>3. Image 组件与图片导入</h2>
<p>Image 组件是 Flutter 中的<code>图片组件</code>，用来展示图片。</p>
<p>它提供多种构造函数，用于指定加载图像的多种方式：</p>
<ul>
<li>Image.asset 加载本地资源图片</li>
<li>Image.network 加载网络图片</li>
<li>Image.file 加载本地文件图片</li>
</ul>
<p><a href="https://api.flutter-io.cn/flutter/widgets/Image-class.html">查看上述方式的详细用法</a></p>
<p>Image组件支持的图片格式有： <strong>JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP</strong>。</p>
<p>默认的构造函数中，通过<code>image</code>参数传入一个指定的<code>ImageProvider</code>类型的值，就可以加载指定的图片。</p>
<p><code>ImageProvider</code> 是一个抽象类，用于提供图片资源。常见的 ImageProvider 类型有 <code>AssetImage</code>、<code>NetworkImage</code>、<code>FileImage</code> 等。</p>
<pre><code class="language-dart"> Image(
  image: AssetImage('assets/images/xxx.png'),
  width: 100,
  height: 100,
),
</code></pre>
<blockquote>
<p>需要注意的是，在使用<code>AssetImage</code>类型的<code>ImageProvider</code>时，需要先在 pubspec.yaml 文件中配置图片资源路径。</p>
<p><img src="../public/Snipaste_phone_image.png" alt="图片8"></p>
</blockquote>
<h2>4. Text 组件与自定义字体</h2>
<p>Text 组件是 Flutter 中的<code>文本组件</code>，用来展示文本。</p>
<p>通过指定<code>style</code>参数，可以设置文本的字体大小、颜色、粗细、斜体等样式。<a href="https://api.flutter-io.cn/flutter/widgets/Text-class.html">查看更多样式设置</a></p>
<pre><code class="language-dart">Text(
  'Hello World!',
  style: TextStyle(
    fontSize: 20,
    color: Colors.blue,
    fontWeight: FontWeight.bold,
    fontStyle: FontStyle.italic,
  ),
),
</code></pre>
<p>以上代码效果如下：</p>
<p><img src="../public/Snipaste_phone_text.png" alt="图片9"></p>
<h3>4.1 自定义字体</h3>
<p>Flutter 支持自定义字体，通过 <code>fontFamily</code> 参数指定字体名称，就可以使用该字体渲染文本。</p>
<pre><code class="language-dart">const Text(
  'Hello World!',
  style: TextStyle(
    fontSize: 20,
    color: Colors.blue,
    fontWeight: FontWeight.bold,
    fontStyle: FontStyle.italic,
    fontFamily: 'PlaywriteDEGrund',
  ),
),
</code></pre>
<p>以上代码效果如下：</p>
<p><img src="../public/Snipaste_phone_custom_font2.png" alt="图片11"></p>
<blockquote>
<p>需要注意的是，自定义字体同样需要在 pubspec.yaml 文件中配置和导入。</p>
<p><img src="../public/Snipaste_phone_custom_font.png" alt="图片10"></p>
</blockquote>
<h2>5. Icon 组件</h2>
<p>Icon 组件是 Flutter 中的<code>图标组件</code>，用来展示具体的图标类型。</p>
<p>通常的做法是<strong>通过指定 flutter 中预定义的 material IconData 枚举值来展示具体的图标</strong>。<a href="https://api.flutter-io.cn/flutter/material/Icons-class.html">查看所有图标类型</a></p>
<pre><code class="language-dart">Icon(
  Icons.favorite,
  size: 30,
  color: Colors.red,
),
</code></pre>
<p>以上代码效果如下：</p>
<p><img src="../public/Snipaste_phone_icon.png" alt="图片12"></p>
]]></content:encoded>
            <author>rongchuancui@gmail.com (Clark Cui)</author>
        </item>
        <item>
            <title><![CDATA[事件循环]]></title>
            <link>https://clark-cui.top/posts/事件循环.html</link>
            <guid>https://clark-cui.top/posts/事件循环.html</guid>
            <pubDate>Sat, 05 Oct 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h2>浏览器的进程模型</h2>
<h3>进程与线程</h3>
<p>进程是正在运行的<u>程序的实例</u>，每个进程都有自己<u>独立的</u>一块内存空间，有了进程之后，才可以运行程序的代码。一个进程至少有一个线程，叫做主线程，一个进程也可以运行多个线程，多个线程可以共享数据。</p>
<h3>浏览器是一个多进程多线程的应用程序</h3>
<p>浏览器是一个极其复杂的应用程序</p>
<p>为了避免多个功能之间的相互影响，减少崩溃的几率，浏览器在启动的时候会启动多个进程。</p>
<p><strong>其中，最主要的进程有</strong>：</p>
<ol>
<li>
<p><strong>浏览器进程</strong></p>
<p>负责界面显示、用户交互、子进程管理等。</p>
</li>
<li>
<p><strong>网络进程</strong></p>
<p>负责网络通信，各种资源的加载。</p>
</li>
<li>
<p><strong>渲染进程</strong></p>
<p>每个标签页都是一个新的渲染进程，渲染进程的主线程负责执行HTML、CSS、JS代码</p>
</li>
</ol>
<h3>渲染主线程是如何工作的</h3>
<p>渲染主线程是浏览器中最繁忙的线程，它处理的任务包括：</p>
<ul>
<li>
<p>解析html</p>
</li>
<li>
<p>解析css</p>
</li>
<li>
<p>计算样式</p>
</li>
<li>
<p>布局</p>
</li>
<li>
<p>处理图层</p>
</li>
<li>
<p>每秒把页面画60次</p>
</li>
<li>
<p>执行全局js代码</p>
</li>
<li>
<p>处理事件函数</p>
</li>
<li>
<p>执行计时器的回调</p>
</li>
<li>
<p>......</p>
</li>
</ul>
<p>为了处理这么多任务的调度，主线程想出了一个办法：队列</p>
<p>当渲染<u>主线程正在执行任务</u>时，由渲染主线程和浏览器<u>其他</u>线程安排的<u>任务</u>会被暂时放<u>到队列中等待执行</u>，当渲染<u>主线程中的任务执行完毕</u>，会<u>从队列中依次取出</u>排队的任务进行<u>执行</u>。</p>
<ol>
<li>
<p>在最开始的时候，渲染主线程会进入一个无线循环</p>
<pre><code class="language-cpp">for(;;){
    
}
</code></pre>
</li>
<li>
<p>每一次循环会检查队列中是否有任务存在，如果有，就取出第一个任务进行执行，执行完后进入下一次循环；如果没有，则进入休眠状态。</p>
</li>
<li>
<p>其他所有的线程（包括其他进程的线程）可以随时向队列添加任务，新添加的任务会被放到队列的末尾。添加任务时，如果主线程是休眠状态，则唤醒</p>
</li>
</ol>
<h3>何为异步？</h3>
<p>在代码执行的过程中，无法立即处理（需要等待）的任务就是异步任务，比如：</p>
<ul>
<li>
<p>计时器安排的任务  <code>setTimeout</code>、<code>setInterval</code></p>
</li>
<li>
<p>网络通信后执行的任务 <code>XHR</code>、<code>fetch</code></p>
</li>
<li>
<p>用户操作后执行的任务 <code>addEventListner</code></p>
</li>
</ul>
<p>渲染主线程不会等待以上任务的执行，而是继续执行主线程需要执行的代码。当以上任务（由浏览器的其他进程）执行完成时，会把执行后的结果放到队列中进行等待（直到主线程清空后依次从队列中取出）。</p>
<h3>JS代码为何会阻塞渲染</h3>
<p>因为js代码和页面渲染都会在渲染主线程中进行执行，而页面的重绘是异步的过程，需要等待主线程的js代码执行完毕。</p>
<h3>队列中的任务有优先级吗？</h3>
<p>队列中的任务没有优先级，都是先进先出</p>
<p>但是<u>队列有优先级</u></p>
<ul>
<li>
<p>每个任务都有一个任务类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同队列中取出任务执行</p>
</li>
<li>
<p>浏览器必须准备好一个微队列，<u>微队列中的任务优先于其他所有任务执行</u>（btw:微队列，vip的v）</p>
<p>添加任务到微队列的方式 <code>Promsie</code> 和<code>MutationObserver</code></p>
<pre><code class="language-javascript">// 立刻把一个函数放到微队列
Promise.resolve().then(函数)
</code></pre>
</li>
</ul>
]]></content:encoded>
            <author>rongchuancui@gmail.com (Clark Cui)</author>
        </item>
        <item>
            <title><![CDATA[浏览器渲染原理]]></title>
            <link>https://clark-cui.top/posts/浏览器渲染原理.html</link>
            <guid>https://clark-cui.top/posts/浏览器渲染原理.html</guid>
            <pubDate>Sat, 05 Oct 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h2>浏览器是如何渲染页面的</h2>
<h3>什么是渲染</h3>
<p>把html字符串转换为像素点信息的过程就可以叫做渲染</p>
<h3>渲染的开始</h3>
<p>当浏览器的网络线程拿到HTML文档后，会产生一个渲染任务，并将其放到队列中。</p>
<p>在事件循环机制的作用下，渲染主线程取出队列中的渲染任务，开启渲染流程。</p>
<h3>渲染流水线</h3>
<ol>
<li>
<p>解析HTML文档</p>
</li>
<li>
<p>样式计算</p>
</li>
<li>
<p>布局</p>
</li>
<li>
<p>分层</p>
</li>
<li>
<p>绘制</p>
</li>
<li>
<p>分块</p>
</li>
<li>
<p>光栅化</p>
</li>
<li>
<p>画</p>
</li>
</ol>
<h3>1. 解析HTML - Parse HTML</h3>
<p>最终结果是把html文档转换成<code>DOM树(文档对象模型)</code>和<code>CSSOM树(CSS 对象模型)</code></p>
<p>渲染的第一步是解析html。</p>
<p>解析过程中<u>遇到css解析css</u>，<u>遇到js执行js</u>。为了提高解析效率，浏览器在开始解析前，会启动一个<u>预解析的线程</u>，率先<u>下载</u>html中的<u>外部css文件</u>和<u>外部的js文件</u>。</p>
<p>如果主线程解析到link位置，此时外部的css文件还没有下载解析好，主线程不会等待，继续后续html的解析。这就是<u>css不会阻塞html解析</u>的根本原因。</p>
<p>如果主线程解析到script位置，会停止解析html，转而执行js代码或者等待js文件下载完毕并执行后，才继续解析html。这是因为，<u>js代码执行的过程中可能会修改当前构建好的dom</u>树，所以必须先暂停解析。<u>这就是js会阻塞html解析的根本原因</u>。</p>
<p>第一步完成后，会得到dom树和cssom树，浏览器的默认样式会包含在cssom树中。</p>
<h3>2. 样式计算 - Recalculate Style</h3>
<p>主线程会遍历得到的dom树，依次为树中的每个节点计算出它最终的样式，称之为<code>Computed Style</code>。</p>
<p>在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px</p>
<h3>3. 布局 - Layout</h3>
<p>主线程在进行layout计算的时候也会生成相应的layout树，需要注意的是，<u>dom树和layout树并不是一一对应的</u>。</p>
<p>比如<code>display: none</code>的节点没有几何信息，因此不会生成到布局树；又比如一些伪元素在dom节点中不存在，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等这些都会导致dom树和布局树无法一一对应。</p>
<h3>4. 分层 - Layer</h3>
<p>主线程会使用一套复杂的策略对整个布局树进行分层。</p>
<p>分层的好处是，如果一个节点经常进行变动，则只需要对该层进行后续处理，而不需要对整个树进行处理，提升了效率。</p>
<p><u>可以通过<code>will-change</code>属性主动影响浏览器的分层结果</u>。</p>
<h3>5. 绘制 - Paint</h3>
<p>主线程会为每个层<u>单独生成</u>绘制指令集，用于<u>描述</u>这一层该<u>如何画出来</u>。</p>
<h3>6. 分块 - Tiling</h3>
<p>上一步完成后，主线程会将每个图层的绘制信息交给合成线程，剩余工作由合成线程完成。</p>
<p>合成线程首先对每个<u>图层</u>进行<u>分块</u>，将其划分成许多的小区域。这一过程是由<u>多个线程</u>完成的。</p>
<h3>7. 光栅化 - Raster</h3>
<p>分块完成后，进入光栅化阶段。</p>
<p>合成线程会将分块信息交给gpu进程，gpu会以极高的速度进行光栅化。</p>
<p><u>光栅化的结果就是一块一块的位图</u>。</p>
<h3>8. 画 - Draw</h3>
<p>最后一个阶段就是画</p>
<p>合成线程从gpu进程中拿到每个块的位图后，生成一个个<u><code>指引（quad）</code>信息</u>。</p>
<p>指引会标识出每个位图应该画到屏幕的哪个位置，并且会考虑旋转、缩放等变形。</p>
<p><u>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的原因</u>。</p>
<p>合成线程会把<code>quad</code>信息交给gpu进程，由gpu进程调用gpu硬件，最终完成屏幕图像的显示。</p>
<h3>关于reflow</h3>
<p><u>reflow的本质就是重新计算layout树</u>。</p>
<p>当进行了影响布局树的操作后，就需要重新计算布局树，触发layout流程。</p>
<p>为了避免连续多次的布局树反复计算，浏览器会合并这些操作，当js代码全部完成后再进行统一的布局树计算。所以，改动属性造成的reflow是异步完成的。</p>
<p>也正是因为如此，当我们在更改布局属性后立即获取它们的信息，就有可能造成无法获取到最新布局信息的结果。</p>
<p>浏览器最终在反复权衡之下，决定获取属性时立即reflow。</p>
<h3>关于repaint</h3>
<p>repaint的本质就是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式后，就需要重新计算，触发repaint流程。</p>
<p>由于元素的布局信息也属于可见样式，所以reflow一定会引起repaint</p>
]]></content:encoded>
            <author>rongchuancui@gmail.com (Clark Cui)</author>
        </item>
        <item>
            <title><![CDATA[测试文章]]></title>
            <link>https://clark-cui.top/posts/作为测试文章.html</link>
            <guid>https://clark-cui.top/posts/作为测试文章.html</guid>
            <pubDate>Thu, 15 Feb 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[测试测试]]></description>
            <content:encoded><![CDATA[<h1>测试一下呢呢</h1>
<p>测试测试</p>
<pre><code class="language-javascript">console.log('test test')
</code></pre>
]]></content:encoded>
            <author>rongchuancui@gmail.com (Clark Cui)</author>
        </item>
    </channel>
</rss>