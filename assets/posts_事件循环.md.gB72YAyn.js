import{_ as s,c as i,o as e,a4 as l}from"./chunks/framework.BicIBzvP.js";const u=JSON.parse('{"title":"事件循环","description":"","frontmatter":{"title":"事件循环","tags":["事件循环","Message Loop","js事件循环"],"date":"2024-03-12T00:00:00.000Z"},"headers":[],"relativePath":"posts/事件循环.md","filePath":"posts/事件循环.md","lastUpdated":1753621617000}'),p={name:"posts/事件循环.md"};function n(t,a,r,o,h,d){return e(),i("div",null,a[0]||(a[0]=[l(`<h2 id="浏览器的进程模型" tabindex="-1">浏览器的进程模型 <a class="header-anchor" href="#浏览器的进程模型" aria-label="Permalink to &quot;浏览器的进程模型&quot;">​</a></h2><h3 id="进程与线程" tabindex="-1">进程与线程 <a class="header-anchor" href="#进程与线程" aria-label="Permalink to &quot;进程与线程&quot;">​</a></h3><p>进程是正在运行的<u>程序的实例</u>，每个进程都有自己<u>独立的</u>一块内存空间，有了进程之后，才可以运行程序的代码。一个进程至少有一个线程，叫做主线程，一个进程也可以运行多个线程，多个线程可以共享数据。</p><h3 id="浏览器是一个多进程多线程的应用程序" tabindex="-1">浏览器是一个多进程多线程的应用程序 <a class="header-anchor" href="#浏览器是一个多进程多线程的应用程序" aria-label="Permalink to &quot;浏览器是一个多进程多线程的应用程序&quot;">​</a></h3><p>浏览器是一个极其复杂的应用程序</p><p>为了避免多个功能之间的相互影响，减少崩溃的几率，浏览器在启动的时候会启动多个进程。</p><p><strong>其中，最主要的进程有</strong>：</p><ol><li><p><strong>浏览器进程</strong></p><p>负责界面显示、用户交互、子进程管理等。</p></li><li><p><strong>网络进程</strong></p><p>负责网络通信，各种资源的加载。</p></li><li><p><strong>渲染进程</strong></p><p>每个标签页都是一个新的渲染进程，渲染进程的主线程负责执行 HTML、CSS、JS 代码</p></li></ol><h3 id="渲染主线程是如何工作的" tabindex="-1">渲染主线程是如何工作的 <a class="header-anchor" href="#渲染主线程是如何工作的" aria-label="Permalink to &quot;渲染主线程是如何工作的&quot;">​</a></h3><p>渲染主线程是浏览器中最繁忙的线程，它处理的任务包括：</p><ul><li><p>解析 html</p></li><li><p>解析 css</p></li><li><p>计算样式</p></li><li><p>布局</p></li><li><p>处理图层</p></li><li><p>每秒把页面画 60 次</p></li><li><p>执行全局 js 代码</p></li><li><p>处理事件函数</p></li><li><p>执行计时器的回调</p></li><li><p>......</p></li></ul><p>为了处理这么多任务的调度，主线程想出了一个办法：队列</p><p>当渲染<u>主线程正在执行任务</u>时，由渲染主线程和浏览器<u>其他</u>线程安排的<u>任务</u>会被暂时放<u>到队列中等待执行</u>，当渲染<u>主线程中的任务执行完毕</u>，会<u>从队列中依次取出</u>排队的任务进行<u>执行</u>。</p><ol><li><p>在最开始的时候，渲染主线程会进入一个无线循环</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes one-dark-pro one-light vp-code" tabindex="0"><code><span class="line"><span style="--shiki-dark:#C678DD;--shiki-light:#A626A4;">for</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">(;;){</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>每一次循环会检查队列中是否有任务存在，如果有，就取出第一个任务进行执行，执行完后进入下一次循环；如果没有，则进入休眠状态。</p></li><li><p>其他所有的线程（包括其他进程的线程）可以随时向队列添加任务，新添加的任务会被放到队列的末尾。添加任务时，如果主线程是休眠状态，则唤醒</p></li></ol><h3 id="何为异步" tabindex="-1">何为异步？ <a class="header-anchor" href="#何为异步" aria-label="Permalink to &quot;何为异步？&quot;">​</a></h3><p>在代码执行的过程中，无法立即处理（需要等待）的任务就是异步任务，比如：</p><ul><li><p>计时器安排的任务 <code>setTimeout</code>、<code>setInterval</code></p></li><li><p>网络通信后执行的任务 <code>XHR</code>、<code>fetch</code></p></li><li><p>用户操作后执行的任务 <code>addEventListner</code></p></li></ul><p>渲染主线程不会等待以上任务的执行，而是继续执行主线程需要执行的代码。当以上任务（由浏览器的其他进程）执行完成时，会把执行后的结果放到队列中进行等待（直到主线程清空后依次从队列中取出）。</p><h3 id="js-代码为何会阻塞渲染" tabindex="-1">JS 代码为何会阻塞渲染 <a class="header-anchor" href="#js-代码为何会阻塞渲染" aria-label="Permalink to &quot;JS 代码为何会阻塞渲染&quot;">​</a></h3><p>因为 js 代码和页面渲染都会在渲染主线程中进行执行，而页面的重绘是异步的过程，需要等待主线程的 js 代码执行完毕。</p><h3 id="队列中的任务有优先级吗" tabindex="-1">队列中的任务有优先级吗？ <a class="header-anchor" href="#队列中的任务有优先级吗" aria-label="Permalink to &quot;队列中的任务有优先级吗？&quot;">​</a></h3><p>队列中的任务没有优先级，都是先进先出</p><p>但是<u>队列有优先级</u></p><ul><li><p>每个任务都有一个任务类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同队列中取出任务执行</p></li><li><p>浏览器必须准备好一个微队列，<u>微队列中的任务优先于其他所有任务执行</u>（btw:微队列，vip 的 v）</p><p>添加任务到微队列的方式 <code>Promsie</code> 和<code>MutationObserver</code></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes one-dark-pro one-light vp-code" tabindex="0"><code><span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">// 立刻把一个函数放到微队列</span></span>
<span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#C18401;">Promise</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#61AFEF;--shiki-light:#4078F2;">resolve</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">().</span><span style="--shiki-dark:#61AFEF;--shiki-light:#4078F2;">then</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">(</span><span style="--shiki-dark:#E06C75;--shiki-light:#383A42;">函数</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul>`,24)]))}const k=s(p,[["render",n]]);export{u as __pageData,k as default};
