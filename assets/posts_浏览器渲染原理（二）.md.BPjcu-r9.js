import{_ as o,C as h,c as p,o as a,a4 as i,b as n,w as s,a as l,G as d,a5 as r}from"./chunks/framework.BicIBzvP.js";const u=JSON.parse('{"title":"浏览器工作原理（二）","description":"","frontmatter":{"title":"浏览器工作原理（二）","tags":["浏览器","渲染原理","reflow","repaint","关键渲染路径"],"date":"2025-7-27","prev":{"text":"浏览器工作原理（一）","link":"/posts/浏览器渲染原理（一）.md"},"next":{"text":"浏览器工作原理（三）","link":"/posts/浏览器渲染原理（三）.md"}},"headers":[],"relativePath":"posts/浏览器渲染原理（二）.md","filePath":"posts/浏览器渲染原理（二）.md","lastUpdated":1755934043000}'),k={name:"posts/浏览器渲染原理（二）.md"};function c(g,t,b,B,E,A){const e=h("Mermaid");return a(),p("div",null,[t[4]||(t[4]=i('<h2 id="浏览器渲染管线" tabindex="-1">浏览器渲染管线 <a class="header-anchor" href="#浏览器渲染管线" aria-label="Permalink to &quot;浏览器渲染管线&quot;">​</a></h2><hr><h3 id="_3-布局阶段-layout-reflow" tabindex="-1">3. 布局阶段 (Layout / Reflow) <a class="header-anchor" href="#_3-布局阶段-layout-reflow" aria-label="Permalink to &quot;3. 布局阶段 (Layout / Reflow)&quot;">​</a></h3><p>布局阶段是将样式计算结果转换为精确几何尺寸的过程，其核心目标是确定每个可见元素在屏幕上的<strong>位置</strong>和<strong>大小</strong>。</p><h4 id="_3-1-构建布局树-layout-tree-construction" tabindex="-1">3.1 构建布局树（Layout Tree Construction） <a class="header-anchor" href="#_3-1-构建布局树-layout-tree-construction" aria-label="Permalink to &quot;3.1 构建布局树（Layout Tree Construction）&quot;">​</a></h4><p>布局树基于渲染树（包含 DOM 结构和计算样式）构建，增加了精确的几何位置信息：</p>',6)),(a(),n(r,null,{default:s(()=>[d(e,{id:"mermaid-16",class:"mermaid",graph:"%20%20flowchart%20TD%0A%20%20A%5B%E6%B8%B2%E6%9F%93%E6%A0%91%5D%20--%3E%20B%5B%E8%BF%87%E6%BB%A4%E4%B8%8D%E5%8F%AF%E8%A7%81%E8%8A%82%E7%82%B9%5D%0A%20%20B%20--%3E%20C%5B%E5%88%9B%E5%BB%BA%E5%B8%83%E5%B1%80%E5%AF%B9%E8%B1%A1%5D%0A%20%20C%20--%3E%20D%5B%E5%A4%84%E7%90%86%E5%8C%BF%E5%90%8D%E7%9B%92%E6%A8%A1%E5%9E%8B%5D%0A%20%20D%20--%3E%20E%5B%E7%94%9F%E6%88%90%E5%B8%83%E5%B1%80%E6%A0%91%5D%0A"})]),fallback:s(()=>t[0]||(t[0]=[l(" Loading... ")])),_:1})),t[5]||(t[5]=i('<p><strong>关键步骤说明</strong>：</p><table tabindex="0"><thead><tr><th>步骤</th><th>操作细节</th><th>关键说明</th></tr></thead><tbody><tr><td>过滤不可见节点</td><td>移除 <code>display: none</code> 的元素；保留 <code>visibility: hidden</code>（占据空间但不可见）</td><td><code>visibility: hidden</code> 仍参与布局计算</td></tr><tr><td>创建布局对象</td><td>为可见元素生成布局对象（LayoutObject），包含样式信息和初始几何属性</td><td>布局对象与 DOM 节点不完全一一对应（如相邻文本节点可能合并）</td></tr><tr><td>处理匿名盒模型</td><td>补全混合内容流的布局层级（如块级容器内的内联内容）</td><td>解决 CSS 盒模型规则下的内容排列问题（见下表示例）</td></tr></tbody></table><p><strong>匿名盒模型示例</strong>：</p><table tabindex="0"><thead><tr><th>匿名盒类型</th><th>产生场景</th><th>示例 HTML</th><th>布局结果</th></tr></thead><tbody><tr><td>匿名块盒</td><td>块级容器中混合块级元素和内联内容</td><td><code>&lt;div&gt;文本&lt;span&gt;内联&lt;/span&gt;&lt;p&gt;块级&lt;/p&gt;更多文本&lt;/div&gt;</code></td><td>生成包含&quot;文本&quot;和&quot;更多文本&quot;的两个匿名块盒，与<code>&lt;p&gt;</code>块级元素垂直排列</td></tr><tr><td>匿名行盒</td><td>块级容器中仅包含内联内容</td><td><code>&lt;p&gt;这是一段需要换行的文本&lt;/p&gt;</code></td><td>文本被包裹在匿名行盒中，根据容器宽度自动换行</td></tr></tbody></table><blockquote><p><strong>注意</strong>：匿名盒无法通过 JavaScript 直接访问，但会影响布局计算（如边距折叠、行高计算）。参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_display/Visual_formatting_model#%E7%9B%92%E5%AD%90%E7%94%9F%E6%88%90" target="_blank" rel="noreferrer">MDN 匿名盒</a></p></blockquote><h4 id="_3-2-布局计算-layout-computation" tabindex="-1">3.2 布局计算（Layout Computation） <a class="header-anchor" href="#_3-2-布局计算-layout-computation" aria-label="Permalink to &quot;3.2 布局计算（Layout Computation）&quot;">​</a></h4><p>布局计算的核心是为布局树中的每个节点计算精确的宽度、高度、位置（top/left/right/bottom），依赖<strong>包含块</strong>（元素布局的参考坐标系）。</p><h5 id="_3-2-1-包含块的确定规则" tabindex="-1">3.2.1 包含块的确定规则 <a class="header-anchor" href="#_3-2-1-包含块的确定规则" aria-label="Permalink to &quot;3.2.1 包含块的确定规则&quot;">​</a></h5><table tabindex="0"><thead><tr><th>元素定位类型</th><th>包含块规则</th><th>例外情况（触发新包含块的祖先属性）</th></tr></thead><tbody><tr><td><code>static/relative/sticky</code></td><td>由最近的块级祖先元素的<strong>内容盒（content box）</strong> 创建</td><td>无</td></tr><tr><td><code>absolute</code></td><td>由最近的非<code>static</code>定位祖先元素的<strong>内边距盒（padding box）</strong> 创建；无则用初始包含块</td><td>祖先满足以下任一条件：<br>1. <code>transform/perspective</code> ≠ <code>none</code><br>2. <code>will-change: transform/perspective</code><br>3. <code>filter</code> ≠ <code>none</code> 或者 <code>will-change: filter</code>（Firfox） <br>4. <code>contain: layout/paint/strict/content</code> <br>5. <code>backdrop-filter</code> ≠ <code>none</code>（有争议）</td></tr><tr><td><code>fixed</code></td><td>默认由视口（viewport）或分页媒体的分页区域创建</td><td>同上（<code>transform</code>等属性会改变包含块）</td></tr></tbody></table><blockquote><p>参考：<br>- <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_display/Containing_block" target="_blank" rel="noreferrer">MDN 包含块</a><br>- <a href="https://www.w3.org/TR/css-position-3/#containing-block" target="_blank" rel="noreferrer">W3C CSS Positioned Layout</a></p></blockquote><h5 id="_3-2-2-几何属性计算顺序与特殊布局" tabindex="-1">3.2.2 几何属性计算顺序与特殊布局 <a class="header-anchor" href="#_3-2-2-几何属性计算顺序与特殊布局" aria-label="Permalink to &quot;3.2.2 几何属性计算顺序与特殊布局&quot;">​</a></h5><p>布局计算从根元素（<code>&lt;html&gt;</code>）开始递归处理子元素，核心计算内容包括：</p><table tabindex="0"><thead><tr><th>计算内容</th><th>依赖因素</th><th>特殊布局模式的影响</th></tr></thead><tbody><tr><td>宽度/高度</td><td><code>width/height</code>、<code>padding</code>、<code>border</code>、<code>margin</code>、内容尺寸（如<code>width: auto</code>自适应）</td><td>块级格式化上下文（BFC）会垂直排列元素并合并边距；弹性布局（Flexbox）按主轴分配空间</td></tr><tr><td>位置（top/left）</td><td>包含块的左上角坐标 + 自身定位属性（如<code>position: absolute</code>的<code>left: 10px</code>）</td><td>浮动布局（Float）会脱离文档流，父元素可能高度塌陷；网格布局（Grid）按轨道对齐</td></tr></tbody></table><p><strong>特殊布局模式对比</strong>：</p><table tabindex="0"><thead><tr><th>布局模式</th><th>核心特性</th><th>典型应用场景</th></tr></thead><tbody><tr><td>块级格式化上下文（BFC）</td><td>垂直排列元素、合并边距、包含浮动元素</td><td>防止浮动父元素高度塌陷（<code>overflow: hidden</code>触发 BFC）</td></tr><tr><td>弹性布局（Flexbox）</td><td>主轴/交叉轴空间分配、弹性因子、对齐控制</td><td>一维布局（导航栏、卡片列表）</td></tr><tr><td>网格布局（Grid）</td><td>二维轨道划分、隐式网格创建、对齐控制</td><td>复杂二维布局（仪表盘、网格图库）</td></tr><tr><td>浮动布局（Float）</td><td>元素脱离文档流、文字环绕、父元素高度塌陷</td><td>多列布局（传统新闻网站）</td></tr></tbody></table><blockquote><p>参考：<br>- <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_display/Block_formatting_context" target="_blank" rel="noreferrer">MDN 块级格式化上下文</a><br>- <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout" target="_blank" rel="noreferrer">MDN 弹性布局</a><br>- <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_grid_layout" target="_blank" rel="noreferrer">MDN 网格布局</a><br>- <a href="https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/CSS_layout/Floats" target="_blank" rel="noreferrer">MDN 浮动布局</a></p></blockquote><h4 id="_3-3-增量布局与性能优化" tabindex="-1">3.3 增量布局与性能优化 <a class="header-anchor" href="#_3-3-增量布局与性能优化" aria-label="Permalink to &quot;3.3 增量布局与性能优化&quot;">​</a></h4><p>为避免全量重排（Full Reflow），浏览器采用<strong>增量布局</strong>策略，仅更新受影响的子树。</p><p><strong>增量布局机制（Incremental Layout）</strong>：</p>',19)),(a(),n(r,null,{default:s(()=>[d(e,{id:"mermaid-313",class:"mermaid",graph:"%20%20flowchart%20LR%0A%20%20A%5BDOM%E4%BF%AE%E6%94%B9%5D%20--%3E%20B%5B%E6%A0%87%E8%AE%B0'%E8%84%8F'%E8%8A%82%E7%82%B9%5D%0A%20%20B%20--%3E%20C%7B%E6%98%AF%E5%90%A6%E5%9C%A8%E5%B8%83%E5%B1%80%E8%BE%B9%E7%95%8C%E5%86%85%EF%BC%9F%7D%0A%20%20C%20--%3E%7C%E6%98%AF%7C%20D%5B%E5%B1%80%E9%83%A8%E9%87%8D%E6%8E%92%5D%0A%20%20C%20--%3E%7C%E5%90%A6%7C%20E%5B%E6%95%B4%E6%A0%91%E9%87%8D%E6%8E%92%5D%0A"})]),fallback:s(()=>t[1]||(t[1]=[l(" Loading... ")])),_:1})),t[6]||(t[6]=i(`<p><strong>关键规则</strong>：</p><ul><li><strong>脏节点</strong>：当 DOM 结构、样式或几何属性发生变化时，可能需要重建布局树。</li><li><strong>布局边界</strong>：父节点的布局范围限制（如<code>overflow: hidden</code>的容器会截断子节点的重排影响）。</li></ul><blockquote><p>参考：<a href="https://web.dev/articles/howbrowserswork?hl=zh-cn#layout" target="_blank" rel="noreferrer">Web Dev howbrowserswork</a></p></blockquote><p><strong>强制同步布局（Forced Synchronous Layout）</strong>：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes one-dark-pro one-light vp-code" tabindex="0"><code><span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">// 错误示例：连续交叉读写布局属性导致触发多次重排</span></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">// 步骤1：写操作（修改width）</span></span>
<span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#383A42;">element</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E5C07B;--shiki-light:#E45649;">style</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#E45649;">width</span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;"> =</span><span style="--shiki-dark:#98C379;--shiki-light:#50A14F;"> &#39;100px&#39;</span></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">// 浏览器：暂存这个修改，标记为脏节点，不立即布局</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">// 步骤2：读操作（获取offsetWidth）</span></span>
<span class="line"><span style="--shiki-dark:#C678DD;--shiki-light:#A626A4;">const</span><span style="--shiki-dark:#E5C07B;--shiki-light:#986801;"> width</span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;"> =</span><span style="--shiki-dark:#E5C07B;--shiki-light:#383A42;"> element</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#E45649;">offsetWidth</span></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">// 浏览器：必须返回最新宽度，所以强制执行步骤1的布局计算（第一次布局）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">// 步骤3：写操作（修改height）</span></span>
<span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#383A42;">element</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E5C07B;--shiki-light:#E45649;">style</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#E45649;">height</span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;"> =</span><span style="--shiki-dark:#98C379;--shiki-light:#50A14F;"> &#39;200px&#39;</span></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">// 浏览器：暂存这个修改，标记为脏节点，等待下一次布局时机</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li><strong>后果</strong>：每次读操作都会触发浏览器立即执行重排，导致性能损耗。</li><li><strong>优化</strong>：</li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes one-dark-pro one-light vp-code" tabindex="0"><code><span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">// 读写分离：先批量读，再批量写；或者先批量写，再批量读</span></span>
<span class="line"><span style="--shiki-dark:#61AFEF;--shiki-light:#4078F2;">requestAnimationFrame</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">(() </span><span style="--shiki-dark:#C678DD;--shiki-light:#A626A4;">=&gt;</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;"> {</span></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">	// 1. 先读后写</span></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">	// 先执行读操作（获取当前布局信息）</span></span>
<span class="line"><span style="--shiki-dark:#C678DD;--shiki-light:#A626A4;">	const</span><span style="--shiki-dark:#E5C07B;--shiki-light:#986801;"> width</span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;"> =</span><span style="--shiki-dark:#E5C07B;--shiki-light:#383A42;"> element</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#E45649;">offsetWidth</span></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">	// 再执行所有写操作（批量暂存）</span></span>
<span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#383A42;">	element</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E5C07B;--shiki-light:#E45649;">style</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#E45649;">width</span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;"> =</span><span style="--shiki-dark:#98C379;--shiki-light:#50A14F;"> &#39;100px&#39;</span></span>
<span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#383A42;">	element</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E5C07B;--shiki-light:#E45649;">style</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#E45649;">height</span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;"> =</span><span style="--shiki-dark:#98C379;--shiki-light:#50A14F;"> &#39;200px&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">	// 2. 先写后读</span></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">	// 先执行所有写操作（批量暂存）</span></span>
<span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#383A42;">	element</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E5C07B;--shiki-light:#E45649;">style</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#E45649;">width</span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;"> =</span><span style="--shiki-dark:#98C379;--shiki-light:#50A14F;"> &#39;100px&#39;</span></span>
<span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#383A42;">	element</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E5C07B;--shiki-light:#E45649;">style</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#E45649;">height</span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;"> =</span><span style="--shiki-dark:#98C379;--shiki-light:#50A14F;"> &#39;200px&#39;</span></span>
<span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;">	// 最后执行读操作（触发一次布局）</span></span>
<span class="line"><span style="--shiki-dark:#C678DD;--shiki-light:#A626A4;">	const</span><span style="--shiki-dark:#E5C07B;--shiki-light:#986801;"> width</span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;"> =</span><span style="--shiki-dark:#E5C07B;--shiki-light:#383A42;"> element</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#E45649;">offsetWidth</span></span>
<span class="line"><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>关键结论</strong>： 连续的多次读操作（中间无写操作）是安全的，浏览器会通过缓存机制优化，不会重复计算布局，性能开销很小。 <strong>真正需要避免的是 “写 - 读 - 写”“读 - 写 - 读” 这类读写交替的操作，它们会频繁打破浏览器的优化机制，导致多次布局计算</strong>。</p><h3 id="_4-分层阶段-layer-stage" tabindex="-1">4. 分层阶段（Layer Stage） <a class="header-anchor" href="#_4-分层阶段-layer-stage" aria-label="Permalink to &quot;4. 分层阶段（Layer Stage）&quot;">​</a></h3><p>分层阶段的目标是将布局树中的元素分配到不同的渲染层（Render Layers），通过隔离动态内容、复用静态内容提升渲染效率。</p><h4 id="_4-1-分层触发条件" tabindex="-1">4.1 分层触发条件 <a class="header-anchor" href="#_4-1-分层触发条件" aria-label="Permalink to &quot;4.1 分层触发条件&quot;">​</a></h4><p>元素被分配到独立渲染层的条件（满足任意一条即触发）：</p><table tabindex="0"><thead><tr><th>触发类型</th><th>具体条件</th><th>示例 HTML/CSS</th></tr></thead><tbody><tr><td>默认分层</td><td>文档根元素（<code>&lt;html&gt;</code>）</td><td><code>&lt;html&gt;...&lt;/html&gt;</code></td></tr><tr><td>定位与堆叠</td><td>- <code>position: absolute/relative</code>且<code>z-index ≠ auto</code><br> - <code>position: fixed/sticky</code><br>- flex/grid 容器的子元素且 <code>z-index ≠ auto</code></td><td><code>&lt;div style=&quot;position: absolute; z-index: 10;&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>视觉效果属性</td><td>- <code>opacity &lt; 1</code><br>- <code>mix-blend-mode ≠ normal</code><br>- <code>transform/perspective/filter/backdrop-filter/clip-path/mask ≠ none</code></td><td><code>&lt;div style=&quot;transform: translateZ(0);&quot;&gt;&lt;/div&gt;</code>（触发 GPU 加速）</td></tr><tr><td>媒体与插件</td><td><code>&lt;video&gt;</code>、<code>&lt;canvas&gt;</code>、<code>&lt;iframe&gt;</code>、WebGL 上下文</td><td><code>&lt;video src=&quot;video.mp4&quot; controls&gt;&lt;/video&gt;</code></td></tr><tr><td>溢出与滚动</td><td><code>overflow: auto/scroll</code>且内容超出容器尺寸（产生实际滚动条）</td><td><code>&lt;div style=&quot;overflow: auto; height: 300px;&quot;&gt;长内容...&lt;/div&gt;</code></td></tr><tr><td>主动提示</td><td>- <code>will-change: 可触发分层的属性</code>（如<code>transform</code>、<code>opacity</code>）<br>- <code>contain: layout/paint/strict/content</code></td><td><code>&lt;div style=&quot;will-change: transform;&quot;&gt;&lt;/div&gt;</code>（预优化动画元素）</td></tr></tbody></table><blockquote><p><strong>合成层的内存成本</strong>：虽然合成层提升性能，但过多的合成层可能导致内存占用增加。</p><p><strong>合成层的合并</strong>：浏览器会尝试合并相邻的静态层以减少 GPU 资源消耗。</p></blockquote><h4 id="_4-2-渲染层与合成层的层级关系" tabindex="-1">4.2 渲染层与合成层的层级关系 <a class="header-anchor" href="#_4-2-渲染层与合成层的层级关系" aria-label="Permalink to &quot;4.2 渲染层与合成层的层级关系&quot;">​</a></h4><p>分层并非单一层级，而是存在&quot;渲染层 → 合成层&quot;的升级关系：</p>`,16)),(a(),n(r,null,{default:s(()=>[d(e,{id:"mermaid-463",class:"mermaid",graph:"%20%20graph%20TD%0A%20%20A%5B%E5%B8%83%E5%B1%80%E6%A0%91%5D%20--%3E%20B(%E6%B8%B2%E6%9F%93%E5%B1%82%20RenderLayer)%0A%20%20B%20--%3E%20C%7B%E6%BB%A1%E8%B6%B3%E5%90%88%E6%88%90%E6%9D%A1%E4%BB%B6%3F%7D%0A%20%20C%20--%3E%7C%E6%98%AF%7C%20D%5B%E5%90%88%E6%88%90%E5%B1%82%20CompositingLayer%5D%0A%20%20C%20--%3E%7C%E5%90%A6%7C%20E%5B%E5%90%88%E5%B9%B6%E5%88%B0%E7%88%B6%E5%90%88%E6%88%90%E5%B1%82%5D%0A%20%20D%20--%3E%20F%5BGPU%E7%BA%B9%E7%90%86%5D%0A"})]),fallback:s(()=>t[2]||(t[2]=[l(" Loading... ")])),_:1})),t[7]||(t[7]=i('<table tabindex="0"><thead><tr><th>层级类型</th><th>特性与优化</th><th>典型场景</th></tr></thead><tbody><tr><td>渲染层</td><td>存储绘制指令，管理层叠顺序</td><td>静态文本块、无动画的按钮</td></tr><tr><td>合成层</td><td>独立 GPU 纹理、由合成线程直接处理、支持 GPU 加速动画</td><td>动画元素（<code>transform: translate</code>）、半透明浮层（<code>opacity: 0.8</code>）</td></tr></tbody></table><h4 id="_4-3-层的堆叠与排序" tabindex="-1">4.3 层的堆叠与排序 <a class="header-anchor" href="#_4-3-层的堆叠与排序" aria-label="Permalink to &quot;4.3 层的堆叠与排序&quot;">​</a></h4><p>层叠顺序由<strong>层叠上下文</strong>决定，子层无法超出父层的堆叠范围。</p><ol><li><p><strong>层叠上下文规则</strong>：</p><ul><li>每个层有自己的&quot;层序&quot;（类似全局<code>z-index</code>）。</li><li>堆叠顺序遵循<a href="https://www.w3.org/TR/css-position-3/#stacking-context" target="_blank" rel="noreferrer">CSS Positioned Layout 3</a>规范：</li></ul><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes one-dark-pro one-light vp-code" tabindex="0"><code><span class="line"><span>背景与边框 → 负z-index层 → 块级元素 → 浮动元素 → 行内元素 → 正z-index层</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p><strong>合成层排序示例</strong>：</p></li></ol>',4)),(a(),n(r,null,{default:s(()=>[d(e,{id:"mermaid-534",class:"mermaid",graph:"%20%20flowchart%20TB%0A%20%20A%5B%E6%A0%B9%E5%90%88%E6%88%90%E5%B1%82%5D%20--%3E%20B%5B%E5%B1%82A%20z-index%3A1%5D%0A%20%20A%20--%3E%20C%5B%E5%B1%82B%20z-index%3A5%5D%0A%20%20A%20--%3E%20D%5B%E5%B1%82C%20z-index%3A10%5D%0A%20%20D%20--%3E%20E%5B%E5%AD%90%E5%B1%82%20z-index%3A15%5D%0A"})]),fallback:s(()=>t[3]||(t[3]=[l(" Loading... ")])),_:1})),t[8]||(t[8]=i('<h4 id="_4-4-层的优化策略" tabindex="-1">4.4 层的优化策略 <a class="header-anchor" href="#_4-4-层的优化策略" aria-label="Permalink to &quot;4.4 层的优化策略&quot;">​</a></h4><p>浏览器通过合并与拆分层平衡内存与性能：</p><table tabindex="0"><thead><tr><th>优化操作</th><th>触发条件</th><th>性能影响</th></tr></thead><tbody><tr><td>层合并</td><td>同层级且无重叠的静态层</td><td>减少 GPU 内存占用，降低合成开销</td></tr><tr><td>层拆分（瓦片化）</td><td>大尺寸层（如长列表）、超出视口的层</td><td>拆分为 256x256 瓦片，仅光栅化可视区域，减少内存占用</td></tr><tr><td>层提升（Promote）</td><td>动画元素（<code>transform/opacity</code>）、频繁重绘的元素</td><td>提升至合成层，避免触发重排重绘</td></tr></tbody></table><blockquote><p><strong>最佳实践</strong>：对动画元素使用<code>transform</code>替代<code>top/left</code>，触发合成层以提升性能。</p></blockquote>',4))])}const m=o(k,[["render",c]]);export{u as __pageData,m as default};
