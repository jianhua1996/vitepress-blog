import{_ as E,C as c,c as h,o as r,j as d,b as n,a4 as l,a as e,w as a,G as i,a5 as s}from"./chunks/framework.BicIBzvP.js";const f=JSON.parse('{"title":"浏览器工作原理（三）","description":"","frontmatter":{"title":"浏览器工作原理（三）","tags":["浏览器","渲染原理","reflow","repaint","关键渲染路径"],"date":"2025-8-23","prev":{"text":"浏览器工作原理（二）","link":"/posts/浏览器渲染原理（二）.md"}},"headers":[],"relativePath":"posts/浏览器渲染原理（三）.md","filePath":"posts/浏览器渲染原理（三）.md","lastUpdated":1755934043000}'),B={name:"posts/浏览器渲染原理（三）.md"};function _(A,t,g,p,m,b){const o=c("Mermaid");return r(),h("div",null,[t[2]||(t[2]=d("h2",{id:"浏览器渲染管线",tabindex:"-1"},[e("浏览器渲染管线 "),d("a",{class:"header-anchor",href:"#浏览器渲染管线","aria-label":'Permalink to "浏览器渲染管线"'},"​")],-1)),t[3]||(t[3]=d("hr",null,null,-1)),t[4]||(t[4]=d("h3",{id:"_5-绘制-painting",tabindex:"-1"},[e("5 绘制（Painting） "),d("a",{class:"header-anchor",href:"#_5-绘制-painting","aria-label":'Permalink to "5 绘制（Painting）"'},"​")],-1)),t[5]||(t[5]=d("p",null,[e("绘制发生在主线程 ​​，目标是将布局树中的元素转换为"),d("strong",null,"绘制指令列表（Paint Records）"),e(" ​​，为后续的合成阶段提供数据支持。")],-1)),(r(),n(s,null,{default:a(()=>[i(o,{id:"mermaid-10",class:"mermaid",graph:"flowchart%20LR%0A%20%20A%5B%E5%B8%83%E5%B1%80%E6%A0%91%5D%20--%3E%20B%5B%E7%94%9F%E6%88%90%E7%BB%98%E5%88%B6%E6%8C%87%E4%BB%A4%5D%0A%20%20B%20--%3E%20C%5B%E5%85%89%E6%A0%85%E5%8C%96%5D%0A%20%20C%20--%3E%20D%5B%E4%BD%8D%E5%9B%BE%E6%95%B0%E6%8D%AE%5D%0A%20%20D%20--%3E%20E%5B%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%5D%0A"})]),fallback:a(()=>t[0]||(t[0]=[e(" Loading... ")])),_:1})),t[6]||(t[6]=l('<p><strong>关键步骤说明</strong>：</p><ul><li><strong>生成绘制指令</strong>：主线程遍历布局树，为每个元素生成 <strong>绘制指令列表（Paint Records）</strong>，描述其颜色、背景、边框、文本等视觉属性。</li><li><strong>按层划分任务</strong>：每个合成层（Compositing Layer）独立生成绘制指令，避免跨层混合。</li><li><strong>提交至合成线程</strong>：主线程将绘制指令和图层信息传递给合成线程，完成后续处理。</li></ul><blockquote><p>注意：绘制指令是一种底层的、描述如何渲染元素的抽象操作列表，实际由浏览器引擎生成。我们可以暂时理解为类似 <code>canvas api</code> 的指令集。</p></blockquote><h4 id="_5-1-绘制指令类型" tabindex="-1">5.1 绘制指令类型 <a class="header-anchor" href="#_5-1-绘制指令类型" aria-label="Permalink to &quot;5.1 绘制指令类型&quot;">​</a></h4><table tabindex="0"><thead><tr><th>指令类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>fillRect</code></td><td>填充矩形区域</td><td>背景颜色、边框</td></tr><tr><td><code>drawText</code></td><td>绘制文本</td><td>字体、颜色、阴影</td></tr><tr><td><code>drawImage</code></td><td>绘制图像</td><td>背景图片、图标</td></tr><tr><td><code>drawBorder</code></td><td>绘制边框</td><td>边框样式、圆角</td></tr><tr><td><code>drawShadow</code></td><td>绘制阴影</td><td>文本阴影、盒阴影</td></tr></tbody></table><h4 id="_5-2-绘制顺序规则" tabindex="-1">5.2 绘制顺序规则 <a class="header-anchor" href="#_5-2-绘制顺序规则" aria-label="Permalink to &quot;5.2 绘制顺序规则&quot;">​</a></h4>',6)),(r(),n(s,null,{default:a(()=>[i(o,{id:"mermaid-114",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20A%5B%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F%5D%20--%3E%20B%5B%E6%96%87%E6%A1%A3%E6%B5%81%E9%A1%BA%E5%BA%8F%5D%0A%20%20%20%20B%20--%3E%20C%5B%E5%A0%86%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%5D%0A%20%20%20%20C%20--%3E%20D%5Bz-index%5D%0A%20%20%20%20D%20--%3E%20E%5B%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F%5D%0A"})]),fallback:a(()=>t[1]||(t[1]=[e(" Loading... ")])),_:1})),t[7]||(t[7]=l('<table tabindex="0"><thead><tr><th>因素</th><th>说明</th></tr></thead><tbody><tr><td>文档流顺序</td><td>默认从上到下、从左到右绘制</td></tr><tr><td>堆叠上下文与 z-index</td><td>不同堆叠上下文的元素按 <code>z-index</code> 排序，同一上下文内按 CSS 层叠规则排序</td></tr></tbody></table><h4 id="_5-3-触发重绘的操作" tabindex="-1">5.3 触发重绘的操作 <a class="header-anchor" href="#_5-3-触发重绘的操作" aria-label="Permalink to &quot;5.3 触发重绘的操作&quot;">​</a></h4><table tabindex="0"><thead><tr><th>操作</th><th>是否触发重绘</th><th>说明</th></tr></thead><tbody><tr><td>修改颜色、背景</td><td>✅</td><td>如 <code>element.style.backgroundColor = &#39;red&#39;</code></td></tr><tr><td>修改字体大小</td><td>✅</td><td>如 <code>element.style.fontSize = &#39;20px&#39;</code></td></tr><tr><td>修改 transform</td><td>❌</td><td>直接由合成线程处理</td></tr><tr><td>修改 opacity</td><td>❌</td><td>直接由合成线程处理</td></tr></tbody></table><h4 id="_5-4-绘制指令的优化" tabindex="-1">5.4 绘制指令的优化 <a class="header-anchor" href="#_5-4-绘制指令的优化" aria-label="Permalink to &quot;5.4 绘制指令的优化&quot;">​</a></h4><p><strong>优化策略</strong>：</p><ul><li><strong>减少绘制指令</strong>：避免频繁修改样式，如批量读写布局属性。</li><li><strong>合并绘制指令</strong>：通过 <code>will-change</code> 或 <code>transform</code> 触发合成层，减少主线程压力。</li><li><strong>简化 CSS 选择器</strong>：避免复杂选择器（如<code>.box .title</code>），减少样式计算时间。</li><li><strong>使用硬件加速</strong>：通过 <code>transform: translateZ(0)</code> 或 <code>will-change: transform</code> 提升合成层性能。</li></ul>',6))])}const x=E(B,[["render",_]]);export{f as __pageData,x as default};
