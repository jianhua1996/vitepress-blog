import{_ as o,c as l,o as e,a4 as i}from"./chunks/framework.BicIBzvP.js";const h=JSON.parse('{"title":"浏览器工作原理（二）","description":"","frontmatter":{"title":"浏览器工作原理（二）","tags":["浏览器","渲染原理","reflow","repaint","关键渲染路径"],"date":"2025-7-27","prev":{"text":"浏览器工作原理（一）","link":"/posts/浏览器渲染原理（一）.md"}},"headers":[],"relativePath":"posts/浏览器渲染原理（二）.md","filePath":"posts/浏览器渲染原理（二）.md","lastUpdated":1753621617000}'),r={name:"posts/浏览器渲染原理（二）.md"};function a(n,t,d,s,c,g){return e(),l("div",null,t[0]||(t[0]=[i('<h2 id="浏览器渲染管线" tabindex="-1">浏览器渲染管线 <a class="header-anchor" href="#浏览器渲染管线" aria-label="Permalink to &quot;浏览器渲染管线&quot;">​</a></h2><h3 id="_3-布局阶段-layout" tabindex="-1">3. 布局阶段 (Layout) <a class="header-anchor" href="#_3-布局阶段-layout" aria-label="Permalink to &quot;3. 布局阶段 (Layout)&quot;">​</a></h3><p><strong>具体流程</strong></p><h4 id="_3-1-构建布局树-layout-tree" tabindex="-1">3.1 构建布局树（Layout Tree） <a class="header-anchor" href="#_3-1-构建布局树-layout-tree" aria-label="Permalink to &quot;3.1 构建布局树（Layout Tree）&quot;">​</a></h4><ul><li>从渲染树（包含样式信息的 DOM 树）出发，过滤掉不需要渲染的节点： <ul><li>移除 <code>display: none</code> 的元素</li><li><strong>保留 <code>visibility: hidden</code> 的元素</strong>（占据空间但不绘制）</li></ul></li><li>生成仅包含可见元素的布局树</li><li>布局树节点包含： <ul><li>几何属性（位置、大小）</li><li>父元素与子元素的层级关系</li></ul></li></ul><h4 id="_3-2-递归计算几何信息" tabindex="-1">3.2 递归计算几何信息 <a class="header-anchor" href="#_3-2-递归计算几何信息" aria-label="Permalink to &quot;3.2 递归计算几何信息&quot;">​</a></h4><p>从根节点（<code>&lt;html&gt;</code>）递归遍历布局树，计算每个元素的<strong>盒模型</strong>和<strong>定位信息</strong>：</p><ol><li><p><strong>确定包含块（Containing Block）</strong>：</p><table tabindex="0"><thead><tr><th>定位类型</th><th>包含块规则</th><th>边界类型</th></tr></thead><tbody><tr><td><code>static</code>/<code>relative</code></td><td>最近块级祖先的<strong>内容盒</strong><br>(块容器或格式化上下文祖先)</td><td>content box</td></tr><tr><td><code>absolute</code></td><td>最近非<code>static</code>祖先的<strong>内边距盒</strong><br>(无则使用初始包含块)</td><td>padding box</td></tr><tr><td><code>fixed</code></td><td><strong>视口</strong><br>或设置以下属性的祖先：<br><code>transform</code>/<code>perspective</code>/<code>filter</code>/<code>contain: paint</code></td><td>padding box</td></tr><tr><td><code>sticky</code></td><td>最近<strong>滚动祖先</strong>的内容盒<br>(无则使用视口)</td><td>content box</td></tr></tbody></table><blockquote><p><strong>关键概念</strong>：包含块是元素尺寸计算（<code>width/height/padding/margin</code>）和位置计算（<code>top/right/bottom/left</code>）的参考基准。<br><strong>依据</strong>：<a href="https://www.w3.org/TR/CSS2/visudet.html#containing-block-details" target="_blank" rel="noreferrer">Definition of &quot;containing block&quot;</a></p></blockquote></li><li><p><strong>处理盒模型</strong>：</p><ul><li>根据 <code>width/height</code> 计算内容区域</li><li>处理 <code>padding</code>/<code>border</code>/<code>margin</code> 值</li><li><strong>百分比值</strong>：基于包含块的对应尺寸计算</li><li><strong>auto 值</strong>：根据布局模式自动计算</li></ul></li><li><p><strong>处理定位类型</strong>：</p><ul><li><strong>正常流</strong>： <ul><li>块级元素：垂直堆叠，宽度填满包含块</li><li>行内元素：水平排列（IFC 上下文） <ul><li>计算行高（<code>line-height</code>）</li><li>基线对齐（<code>vertical-align</code>）</li><li>文本对齐（<code>text-align</code>）</li><li>行盒（Line Box）高度计算</li></ul></li></ul></li><li><strong>浮动</strong>： <ul><li>计算 <code>float: left/right</code> 位置</li><li>处理文字环绕效果</li></ul></li><li><strong>绝对定位</strong>： <ul><li>根据包含块计算精确位置</li><li>完全脱离文档流</li></ul></li><li><strong>固定定位</strong>： <ul><li>相对于视口定位</li><li><strong>特例</strong>：祖先设 <code>transform</code> 时锁定在该祖先</li></ul></li><li><strong>粘性定位</strong>： <ul><li>在滚动容器内切换相对/固定定位 <blockquote><p><strong>依据</strong>：<a href="https://drafts.csswg.org/css-position/#positioning-schemes" target="_blank" rel="noreferrer">W3C CSS Positioned Layout §2</a></p></blockquote></li></ul></li></ul></li><li><p><strong>文字排版</strong>：</p><ul><li>在行内格式化上下文（IFC）中计算： <ul><li>文本换行位置</li><li>行盒高度（由行内最高元素决定）</li><li>基线对齐（<code>vertical-align</code>） <blockquote><p><strong>依据</strong>：<a href="https://drafts.csswg.org/css-inline-3/#inline-formatting" target="_blank" rel="noreferrer">W3C CSS Inline Layout §2</a></p></blockquote></li></ul></li></ul></li></ol><h4 id="_3-3-处理复杂布局模式" tabindex="-1">3.3 处理复杂布局模式 <a class="header-anchor" href="#_3-3-处理复杂布局模式" aria-label="Permalink to &quot;3.3 处理复杂布局模式&quot;">​</a></h4><ul><li><p><strong>Flexbox 布局</strong>：</p><ul><li>计算主轴/交叉轴尺寸</li><li>分配剩余空间（<code>flex-grow/shrink</code>）</li><li>处理项目对齐（<code>justify-content</code>/<code>align-items</code>） <blockquote><p><strong>依据</strong>：<a href="https://drafts.csswg.org/css-flexbox-1/#layout-algorithm" target="_blank" rel="noreferrer">W3C Flexbox §9</a></p></blockquote></li></ul></li><li><p><strong>Grid 布局</strong>：</p><ul><li>计算网格轨道（行/列）尺寸</li><li>放置网格项目到指定区域</li><li>处理网格间隙（<code>gap</code>） <blockquote><p><strong>依据</strong>：<a href="https://drafts.csswg.org/css-grid-2/#grid-layout-algorithm" target="_blank" rel="noreferrer">W3C Grid Layout §11</a></p></blockquote></li></ul></li></ul><h4 id="_3-4-存储布局结果" tabindex="-1">3.4 存储布局结果 <a class="header-anchor" href="#_3-4-存储布局结果" aria-label="Permalink to &quot;3.4 存储布局结果&quot;">​</a></h4><ul><li>记录计算得到的几何信息： <ul><li>位置坐标（x, y）</li><li>尺寸（width, height）</li><li>盒模型各部分值（content/padding/border/margin）</li></ul></li><li>建立空间关系： <ul><li>元素间相对位置</li><li>物理重叠情况（为分层阶段准备）</li></ul></li></ul>',12)]))}const p=o(r,[["render",a]]);export{h as __pageData,p as default};
